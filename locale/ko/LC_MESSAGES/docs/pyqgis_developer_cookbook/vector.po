# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2002-now, QGIS project
# This file is distributed under the same license as the QGIS Documentation
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
# 
# Translators:
# Harrissou Sant-anna, 2024
# Transifex Bot <>, 2024
# Kwon.Yongchan <ruvyn@naver.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QGIS Documentation 3.34\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-15 06:58+0000\n"
"PO-Revision-Date: 2024-03-02 11:57+0000\n"
"Last-Translator: Kwon.Yongchan <ruvyn@naver.com>, 2024\n"
"Language-Team: Korean (https://app.transifex.com/qgis/teams/6144/ko/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../<rst_prolog>:5
msgid ""
"Translation is a community effort `you can join "
"<https://qgis.org/en/site/getinvolved/translate.html#becoming-a-"
"translator>`_. This page is currently translated at |translation progress|."
msgstr ""
"번역은 `여러분이 참여할 수 있는 "
"<https://qgis.org/ko/site/getinvolved/translate.html#becoming-a-"
"translator>`_ 커뮤니티 활동입니다. 이 페이지는 현재 |translation progress| 번역되었습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:14
msgid "Using Vector Layers"
msgstr "벡터 레이어 사용하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:16
msgid ""
"The code snippets on this page need the following imports if you're outside "
"the pyqgis console:"
msgstr "PyQGIS 콘솔을 사용하지 않는 경우 이 페이지에 있는 코드 조각들을 다음과 같이 가져와야 합니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:60
msgid ""
"This section summarizes various actions that can be done with vector layers."
msgstr "이 장에서는 벡터 레이어에 대해 할 수 있는 여러 가지 작업들을 소개합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:62
msgid ""
"Most work here is based on the methods of the :class:`QgsVectorLayer "
"<qgis.core.QgsVectorLayer>` class."
msgstr ""
"이 장에서 소개하는 대부분의 작업은  :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` 클래스의"
" 메소드들에 바탕을 두고 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:68
msgid "Retrieving information about attributes"
msgstr "속성에 대한 정보 검색하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:70
msgid ""
"You can retrieve information about the fields associated with a vector layer"
" by calling :meth:`fields() <qgis.core.QgsVectorLayer.fields>` on a "
":class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object:"
msgstr ""
":class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` 클래스 객체에 대해 "
":meth:`fields() <qgis.core.QgsVectorLayer.fields>` 메소드를 호출하면 벡터 레이어와 연관된 "
"필드들에 대한 정보를 검색할 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:89
msgid ""
"The :meth:`displayField() <qgis.core.QgsVectorLayer.displayField>` and "
":meth:`mapTipTemplate() <qgis.core.QgsMapLayer.mapTipTemplate>` methods "
"provide information on the field and template used in the :ref:`maptips` "
"tab."
msgstr ""
":meth:`displayField() <qgis.core.QgsVectorLayer.displayField>` 와 "
":meth:`mapTipTemplate() <qgis.core.QgsMapLayer.mapTipTemplate>` 메소드는 "
":ref:`maptips` 탭에서 쓰이는 필드와 템플릿에 대한 정보를 제공합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:93
msgid ""
"When you load a vector layer, a field is always chosen by QGIS as the "
"``Display Name``, while the ``HTML Map Tip`` is empty by default. With these"
" methods you can easily get both:"
msgstr ""
"벡터 레이어를 불러왔을 때 QGIS는 언제나 필드 하나를 ``Display Name`` 으로 선택하는 반면, ``HTML Map "
"Tip`` 은 기본적으로 비어 있습니다. 이 메소드들을 사용하면 둘 다 손쉽게 가져올 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:107
msgid ""
"If you change the ``Display Name`` from a field to an expression, you have "
"to use :meth:`displayExpression() "
"<qgis.core.QgsVectorLayer.displayExpression>` instead of "
":meth:`displayField() <qgis.core.QgsVectorLayer.displayField>`."
msgstr ""
"``Display Name`` 을 필드에서 표현식으로 변경할 경우, :meth:`displayField() "
"<qgis.core.QgsVectorLayer.displayField>` 대신 :meth:`displayExpression() "
"<qgis.core.QgsVectorLayer.displayExpression>` 메소드를 사용해야 합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:114
msgid "Iterating over Vector Layer"
msgstr "벡터 레이어 작업 반복하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:116
msgid ""
"Iterating over the features in a vector layer is one of the most common "
"tasks. Below is an example of the simple basic code to perform this task and"
" showing some information about each feature. The ``layer`` variable is "
"assumed to have a :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object."
msgstr ""
"벡터 레이어에 있는 피처들에 대한 작업을 반복하는 일은 가장 흔한 작업 가운데 하나입니다. 다음은 이런 작업을 수행하는 단순한 기본 "
"코드의 예시로, 각 피처에 대한 몇몇 정보를 출력합니다. ``layer`` 변수가 :class:`QgsVectorLayer "
"<qgis.core.QgsVectorLayer>` 클래스를 가지고 있다고 가정합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:175
msgid "Selecting features"
msgstr "피처 선택하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:177
msgid ""
"In QGIS desktop, features can be selected in different ways: the user can "
"click on a feature, draw a rectangle on the map canvas or use an expression "
"filter. Selected features are normally highlighted in a different color "
"(default is yellow) to draw user's attention on the selection."
msgstr ""
"QGIS 데스크탑에서 피처를 여러 가지 방법으로 선택할 수 있습니다: 여러분은 피처 하나를 클릭하거나, 맵 캔버스 위에 직사각형을 "
"그리거나, 또는 표현식 필터를 사용할 수 있습니다. 선택 집합에 여러분의 주의를 끌기 위해, 선택된 피처는 보통 다른 (기본값은 노란색)"
" 색상으로 강조됩니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:182
msgid ""
"Sometimes it can be useful to programmatically select features or to change "
"the default color."
msgstr "때로는 프로그래밍 방식으로 피처를 선택하거나 또는 기본 색상을 변경하는 편이 유용할 수도 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:185
msgid ""
"To select all the features, the :meth:`selectAll() "
"<qgis.core.QgsVectorLayer.selectAll>` method can be used:"
msgstr ""
"피처를 모두 선택하려면, :meth:`selectAll() <qgis.core.QgsVectorLayer.selectAll>` 메소드를 "
"사용하면 됩니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:193
msgid ""
"To select using an expression, use the :meth:`selectByExpression() "
"<qgis.core.QgsVectorLayer.selectByExpression>` method:"
msgstr ""
"표현식을 사용해서 선택하려면, :meth:`selectByExpression() "
"<qgis.core.QgsVectorLayer.selectByExpression>` 메소드를 사용하십시오:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:202
msgid ""
"To change the selection color you can use :meth:`setSelectionColor() "
"<qgis.gui.QgsMapCanvas.setSelectionColor>` method of :class:`QgsMapCanvas "
"<qgis.gui.QgsMapCanvas>` as shown in the following example:"
msgstr ""
"선택 집합의 색상을 변경하려면 다음 예시에서 볼 수 있는 바와 같이 :class:`QgsMapCanvas "
"<qgis.gui.QgsMapCanvas>` 클래스의 :meth:`setSelectionColor() "
"<qgis.gui.QgsMapCanvas.setSelectionColor>` 메소드를 사용하면 됩니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:210
msgid ""
"To add features to the selected features list for a given layer, you can "
"call :meth:`select() <qgis.core.QgsVectorLayer.select>` passing to it the "
"list of features IDs:"
msgstr ""
"지정한 레이어의 선택 피처 목록에 피처를 추가하려면, 피처 ID 목록에 피처 ID를 전달하는 :meth:`select() "
"<qgis.core.QgsVectorLayer.select>` 메소드를 호출하면 됩니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:225
msgid "To clear the selection:"
msgstr "선택 집합을 지우려면:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:232
msgid "Accessing attributes"
msgstr "속성에 접근하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:234
msgid "Attributes can be referred to by their name:"
msgstr "속성은 속성 이름으로 참조할 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:244
msgid ""
"Alternatively, attributes can be referred to by index. This is a bit faster "
"than using the name. For example, to get the second attribute:"
msgstr ""
"아니면, 인덱스로 속성을 참조할 수 있습니다. 이름을 사용하는 방법보다 좀 더 빠릅니다. 예를 들어 두 번째 속성을 가져오려면:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:258
msgid "Iterating over selected features"
msgstr "선택한 피처에 대한 작업 반복하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:260
msgid ""
"If you only need selected features, you can use the "
":meth:`selectedFeatures() <qgis.core.QgsVectorLayer.selectedFeatures>` "
"method from the vector layer:"
msgstr ""
"선택한 피처들만 필요한 경우, 벡터 레이어에서 :meth:`selectedFeatures() "
"<qgis.core.QgsVectorLayer.selectedFeatures>` 메소드를 사용하면 됩니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:272
msgid "Iterating over a subset of features"
msgstr "피처 부분 집합에 대한 작업 반복하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:274
msgid ""
"If you want to iterate over a given subset of features in a layer, such as "
"those within a given area, you have to add a :class:`QgsFeatureRequest "
"<qgis.core.QgsFeatureRequest>` object to the :meth:`getFeatures() "
"<qgis.core.QgsVectorLayer.getFeatures>` call. Here's an example:"
msgstr ""
"레이어에 있는 피처들 가운데 지정한 부분 집합에만, 예를 들면 지정한 영역 안에 있는 피처에만 작업을 반복하고 싶은 경우, "
":meth:`getFeatures() <qgis.core.QgsVectorLayer.getFeatures>` 메소드 호출에 "
":class:`QgsFeatureRequest <qgis.core.QgsFeatureRequest>` 클래스 객체를 추가해야 합니다. "
"다음은 그 예시입니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:288
msgid ""
"For the sake of speed, the intersection is often done only using feature’s "
"bounding box. There is however a flag ``ExactIntersect`` that makes sure "
"that only intersecting features will be returned:"
msgstr ""
"속도를 향상시키기 위해, 교차 여부를 확인하는 데 피처의 경계 상자만 사용하는 경우가 많습니다. 하지만 교차하는 피처들만 반환되도록 "
"보장하는 ``ExactIntersect`` 플래그가 존재합니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:297
msgid ""
"With :meth:`setLimit() <qgis.core.QgsFeatureRequest.setLimit>` you can limit"
" the number of requested features. Here's an example:"
msgstr ""
":meth:`setLimit() <qgis.core.QgsFeatureRequest.setLimit>` 메소드를 사용하면 요청한 피처들의"
" 개수를 제한할 수 있습니다. 다음은 그 예시입니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:312
msgid ""
"If you need an attribute-based filter instead (or in addition) of a spatial "
"one like shown in the examples above, you can build a :class:`QgsExpression "
"<qgis.core.QgsExpression>` object and pass it to the "
":class:`QgsFeatureRequest <qgis.core.QgsFeatureRequest>` constructor. Here's"
" an example:"
msgstr ""
"앞의 예시에서 볼 수 있는 것과 같은 공간 필터 대신 (또는 추가로) 속성 기반 필터가 필요한 경우, "
":class:`QgsExpression <qgis.core.QgsExpression>` 클래스 객체를 작성해서 "
":class:`QgsFeatureRequest <qgis.core.QgsFeatureRequest>` 작성자(constructor) "
"클래스로 전달하면 됩니다. 다음은 그 예시입니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:325
msgid ""
"See :ref:`expressions` for the details about the syntax supported by "
":class:`QgsExpression <qgis.core.QgsExpression>`."
msgstr ""
":class:`QgsExpression <qgis.core.QgsExpression>` 클래스가 지원하는 문법(syntax)에 대해 "
"자세히 알고 싶다면 :ref:`expressions` 을 참조하세요."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:327
msgid ""
"The request can be used to define the data retrieved for each feature, so "
"the iterator returns all features, but returns partial data for each of "
"them."
msgstr ""
"요청을 각 피처에 대해 검색된 데이터를 정의하기 위해 사용할 수 있기 때문에, 반복 작업자(iterator)가 모든 피처를 반환하긴 "
"하지만 각 피처의 부분적인 데이터를 반환합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:352
msgid "Modifying Vector Layers"
msgstr "벡터 레이어 수정하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:354
msgid ""
"Most vector data providers support editing of layer data. Sometimes they "
"support just a subset of possible editing actions. Use the "
":meth:`capabilities() <qgis.core.QgsVectorDataProvider.capabilities>` "
"function to find out what set of functionality is supported."
msgstr ""
"벡터 데이터 제공자 대부분은 레이어 데이터의 편집을 지원합니다. 가능한 편집 작업의 일부만 지원하는 경우도 있습니다. 어떤 기능들을 "
"지원하는지 알고 싶다면 :meth:`capabilities() "
"<qgis.core.QgsVectorDataProvider.capabilities>` 함수를 사용해보세요."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:370
msgid ""
"For a list of all available capabilities, please refer to the :class:`API "
"Documentation of QgsVectorDataProvider <qgis.core.QgsVectorDataProvider>`."
msgstr ""
"사용할 수 있는 케이퍼빌리티의 전체 목록을 보고 싶다면 :class:`QgsVectorDataProvider의 API 문서 "
"<qgis.core.QgsVectorDataProvider>` 클래스를 참조해주십시오."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:374
msgid ""
"To print layer's capabilities textual description in a comma separated list "
"you can use :meth:`capabilitiesString() "
"<qgis.core.QgsVectorDataProvider.capabilitiesString>` as in the following "
"example:"
msgstr ""
"레이어의 케이퍼빌리티를 쉼표로 구분된 설명 텍스트로 출력하려면 다음 예시처럼 :meth:`capabilitiesString() "
"<qgis.core.QgsVectorDataProvider.capabilitiesString>` 메소드를 사용하면 됩니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:387
msgid ""
"By using any of the following methods for vector layer editing, the changes "
"are directly committed to the underlying data store (a file, database etc). "
"In case you would like to do only temporary changes, skip to the next "
"section that explains how to do :ref:`modifications with editing buffer "
"<editing-buffer>`."
msgstr ""
"벡터 레이어 편집을 위한 다음 방법들 가운데 어떤 방법을 사용하든, 변경 사항은 기저 데이터 저장소(파일, 데이터베이스 등등)에 직접 "
"반영됩니다. 일시적으로만 변경하고자 할 경우, :ref:`편집 버퍼로 수정 <editing-buffer>` 하는 방법을 설명하는 다음 "
"절로 넘어가십시오."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:395
msgid ""
"If you are working inside QGIS (either from the console or from a plugin), "
"it might be necessary to force a redraw of the map canvas in order to see "
"the changes you've done to the geometry, to the style or to the attributes:"
msgstr ""
"QGIS 안에서 (콘솔에서든 플러그인에서든) 작업하는 경우, 여러분이 도형의 스타일이나 속성을 변경한 결과를 보기 위해 맵 캔버스를 "
"강제로 다시 그리게 해야 할 필요가 있을 수도 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:410
msgid "Add Features"
msgstr "피처 추가하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:412
msgid ""
"Create some :class:`QgsFeature <qgis.core.QgsFeature>` instances and pass a "
"list of them to the provider :class:`QgsVectorDataProvider "
"<qgis.core.QgsVectorDataProvider>` ``addFeatures()`` method. It will return "
"two values: result (:const:`True` or :const:`False`) and list of added "
"features (their ID is set by the data store)."
msgstr ""
":class:`QgsFeature <qgis.core.QgsFeature>` 클래스 인스턴스를 몇 개 생성한 다음 제공자의 "
":class:`QgsVectorDataProvider <qgis.core.QgsVectorDataProvider>` "
"``addFeatures()`` 메소드에 그 목록을 전달하십시오. 이 메소드가 결과(:const:`True` 또는 "
":const:`False`)와 추가된 피처 목록(데이터 저장소가 설정한, 추가된 피처의 피처 ID)이라는 값 2개를 반환할 것입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:417
msgid ""
"To set up the attributes of the feature, you can either initialize the "
"feature passing a :class:`QgsFields <qgis.core.QgsFields>` object (you can "
"obtain that from the :meth:`fields() <qgis.core.QgsVectorLayer.fields>` "
"method of the vector layer) or call :meth:`initAttributes() "
"<qgis.core.QgsFeature.initAttributes>` passing the number of fields you want"
" to be added."
msgstr ""
"피처 속성을 설정하려면, (벡터 레이어의 :meth:`fields() <qgis.core.QgsVectorLayer.fields>` "
"메소드에서 얻을 수 있는) :class:`QgsFields <qgis.core.QgsFields>` 클래스 객체를 전달하는 피처를 "
"초기화하거나, 또는 여러분이 추가하고 싶은 필드들의 개수를 전달하는 :meth:`initAttributes() "
"<qgis.core.QgsFeature.initAttributes>` 메소드를 호출하면 됩니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:436
msgid "Delete Features"
msgstr "피처 삭제하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:438
msgid "To delete some features, just provide a list of their feature IDs."
msgstr "피처를 몇 개 삭제하려면, 삭제하려는 피처의 ID 목록만 지정하면 됩니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:446
msgid "Modify Features"
msgstr "피처 수정하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:448
msgid ""
"It is possible to either change feature's geometry or to change some "
"attributes. The following example first changes values of attributes with "
"index 0 and 1, then it changes the feature's geometry."
msgstr ""
"피처의 도형을 변경하거나 아니면 속성을 몇 개 변경할 수 있습니다. 다음 예시에서는 먼저 인덱스가 0과 1인 속성들의 값을 변경한 다음,"
" 피처의 도형을 변경합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:465
msgid "**Favor QgsVectorLayerEditUtils class for geometry-only edits**"
msgstr "**도형만 편집하는 경우 QgsVectorLayerEditUtils 클래스 권장**"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:467
msgid ""
"If you only need to change geometries, you might consider using the "
":class:`QgsVectorLayerEditUtils <qgis.core.QgsVectorLayerEditUtils>` which "
"provides some useful methods to edit geometries (translate, insert or move "
"vertex, etc.)."
msgstr ""
"도형만 변경해야 하는 경우, 도형을 편집하는 몇 가지 유용한 (꼭짓점 변위, 삽입, 이동 등등의) 메소드들을 제공하는 "
":class:`QgsVectorLayerEditUtils <qgis.core.QgsVectorLayerEditUtils>` 클래스를 "
"사용하는 편이 좋을 수도 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:474
msgid "Modifying Vector Layers with an Editing Buffer"
msgstr "편집 버퍼로 벡터 레이어 수정하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:476
msgid ""
"When editing vectors within QGIS application, you have to first start "
"editing mode for a particular layer, then do some modifications and finally "
"commit (or rollback) the changes. All the changes you make are not written "
"until you commit them --- they stay in layer's in-memory editing buffer. It "
"is possible to use this functionality also programmatically --- it is just "
"another method for vector layer editing that complements the direct usage of"
" data providers. Use this option when providing some GUI tools for vector "
"layer editing, since this will allow user to decide whether to "
"commit/rollback and allows the usage of undo/redo. When changes are "
"committed, all changes from the editing buffer are saved to data provider."
msgstr ""
"QGIS 응용 프로그램 안에서 벡터를 편집할 때, 먼저 특정 레이어에 대한 편집 모드를 시작한 다음 어떤 수정 작업을 하고 마지막으로 "
"변경 사항을 커밋(또는 롤백)해야 합니다. 여러분이 무엇을 수정했든, 모든 변경 사항은 커밋하기 전까지는 작성되지 않습니다 --- "
"레이어의 인메모리(in-memory) 편집 버퍼에 머물 뿐입니다. 이 기능을 프로그래밍 방식으로도 사용할 수 있습니다 --- 그저 데이터"
" 제공자를 직접 사용하는 작업을 보완하는 벡터 레이어 편집의 또다른 방법일 뿐입니다. 벡터 레이어 편집을 위한 몇몇 GUI 도구들을 "
"제공할 때 이 옵션을 사용하십시오. 여러분이 커밋/롤백할지 여부를 결정할 수 있게 해주고, 실행 취소(undo)/다시 실행(redo) "
"기능을 사용할 수 있게 해주기 때문입니다. 변경 사항을 커밋하면, 데이터 제공자에 편집 버퍼에 있는 변경 사항을 전부 저장합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:487
msgid ""
"The methods are similar to the ones we have seen in the provider, but they "
"are called on the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object "
"instead."
msgstr ""
"이 메소드들은 제공자에서 볼 수 있는 메소드들과 비슷하지만, 제공자에서와는 달리 :class:`QgsVectorLayer "
"<qgis.core.QgsVectorLayer>` 클래스 객체에 대해 호출됩니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:491
msgid ""
"For these methods to work, the layer must be in editing mode. To start the "
"editing mode, use the :meth:`startEditing() "
"<qgis.core.QgsVectorLayer.startEditing>` method. To stop editing, use the "
":meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` or "
":meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` methods. The first "
"one will commit all your changes to the data source, while the second one "
"will discard them and will not modify the data source at all."
msgstr ""
"이 메소드들이 작동하기 위해서는 레이어가 반드시 편집 모드 상태여야만 합니다. 편집 모드를 시작하려면, "
":meth:`startEditing() <qgis.core.QgsVectorLayer.startEditing>` 메소드를 사용하십시오. "
"편집을 끝내려면, :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` "
"또는 :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` 메소드를 사용하십시오. 전자는 "
"데이터 소스에 여러분의 변경 사항을 전부 저장할 것이고, 후자는 변경 사항을 버리고 데이터 소스를 하나도 수정하지 않을 것입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:498
msgid ""
"To find out whether a layer is in editing mode, use the :meth:`isEditable() "
"<qgis.core.QgsVectorLayer.isEditable>` method."
msgstr ""
"레이어가 편집 모드 상태인지 알아내려면, :meth:`isEditable() "
"<qgis.core.QgsVectorLayer.isEditable>` 메소드를 사용하십시오."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:501
msgid ""
"Here you have some examples that demonstrate how to use these editing "
"methods."
msgstr "다음은 이 편집 메소드들을 사용하는 방법을 보여주는 몇몇 예시입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:529
msgid ""
"In order to make undo/redo work properly, the above mentioned calls have to "
"be wrapped into undo commands. (If you do not care about undo/redo and want "
"to have the changes stored immediately, then you will have easier work by "
":ref:`editing with data provider <editing>`.)"
msgstr ""
"실행 취소/다시 실행이 제대로 작동하게 하려면, 앞에서 설명한 호출을 실행 취소 명령어 안에 래핑(wrapping)시켜야 합니다. (실행"
" 취소/다시 실행에는 관심이 없고 변경하는 즉시 저장되기를 바라는 경우, :ref:`데이터 제공자로 편집하기 <editing>` 를 통해"
" 더 쉽게 작업하게 될 것입니다.)"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:534
msgid "Here is how you can use the undo functionality:"
msgstr "다음은 실행 취소 기능을 어떻게 사용할 수 있는지 보여주는 예시입니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:551
msgid ""
"The :meth:`beginEditCommand() <qgis.core.QgsVectorLayer.beginEditCommand>` "
"method will create an internal \"active\" command and will record subsequent"
" changes in vector layer. With the call to :meth:`endEditCommand() "
"<qgis.core.QgsVectorLayer.endEditCommand>` the command is pushed onto the "
"undo stack and the user will be able to undo/redo it from GUI. In case "
"something went wrong while doing the changes, the "
":meth:`destroyEditCommand() <qgis.core.QgsVectorLayer.destroyEditCommand>` "
"method will remove the command and rollback all changes done while this "
"command was active."
msgstr ""
":meth:`beginEditCommand() <qgis.core.QgsVectorLayer.beginEditCommand>` 메소드가 "
"내부 \"활성\" 명령어를 생성한 다음 벡터 레이어의 순차적인 변경 사항들을 기록할 것입니다. :meth:`endEditCommand()"
" <qgis.core.QgsVectorLayer.endEditCommand>` 메소드를 호출하면 명령어를 실행 취소 스택으로 넘겨서 "
"여러분이 GUI에서 실행 취소/다시 실행할 수 있게 될 것입니다. 벡터를 변경하는 도중 무언가 문제가 발생한 경우, "
":meth:`destroyEditCommand() <qgis.core.QgsVectorLayer.destroyEditCommand>` "
"메소드가 명령어를 제거하고 해당 명령어가 활성 상태인 동안 발생한 모든 변경 사항들을 롤백시킬 것입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:558
msgid ""
"You can also use the :code:`with edit(layer)`-statement to wrap commit and "
"rollback into a more semantic code block as shown in the example below:"
msgstr ""
"또한 다음 예시에서 볼 수 있는 바와 같이 :code:`with edit(layer)` 선언문을 사용해서 커밋과 롤백을 좀 더 의미를 알"
" 수 있는(sementic) 코드 블록으로 래핑시킬 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:569
msgid ""
"This will automatically call :meth:`commitChanges() "
"<qgis.core.QgsVectorLayer.commitChanges>` in the end. If any exception "
"occurs, it will :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` all "
"the changes. In case a problem is encountered within :meth:`commitChanges() "
"<qgis.core.QgsVectorLayer.commitChanges>` (when the method returns False) a "
":class:`QgsEditError <qgis.core.QgsEditError>` exception will be raised."
msgstr ""
"이 코드는 마지막에 :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` "
"메소드를 자동 호출할 것입니다. 어떤 예외가 발생하는 경우, 이 코드는 모든 변경 사항을 롤백시키는 :meth:`rollBack() "
"<qgis.core.QgsVectorLayer.rollBack>` 메소드를 호출할 것입니다. :meth:`commitChanges() "
"<qgis.core.QgsVectorLayer.commitChanges>` 메소드가 실행되는 동안 문제가 발생하는 경우 (이 메소드가 "
"거짓을 반환하는 경우) :class:`QgsEditError <qgis.core.QgsEditError>` 예외가 발생할 것입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:575
msgid "Adding and Removing Fields"
msgstr "필드 추가하기 및 제거하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:577
msgid ""
"To add fields (attributes), you need to specify a list of field definitions."
" For deletion of fields just provide a list of field indexes."
msgstr "필드(속성)를 추가하려면, 필드를 정의한 리스트를 지정해야 합니다. 필드를 삭제하려면 필드 인덱스 목록만 넘겨주면 됩니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:608
msgid ""
"After adding or removing fields in the data provider the layer's fields need"
" to be updated because the changes are not automatically propagated."
msgstr ""
"데이터 제공자에서 필드를 추가 또는 제거한 다음 레이어의 필드를 업데이트해야 합니다. 변경 사항이 자동적으로 반영되지 않기 때문입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:615
msgid "**Directly save changes using** ``with`` **based command**"
msgstr "``with`` **기반 명령어를 사용해서 변경 사항을 직접 저장하기**"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:617
msgid ""
"Using ``with edit(layer):`` the changes will be committed automatically "
"calling :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` at "
"the end. If any exception occurs, it will :meth:`rollBack() "
"<qgis.core.QgsVectorLayer.rollBack>` all the changes. See :ref:`editing-"
"buffer`."
msgstr ""
"``with edit(layer):`` 선언문을 사용하면 마지막에 :meth:`commitChanges() "
"<qgis.core.QgsVectorLayer.commitChanges>` 메소드를 자동으로 호출해서 변경 사항을 커밋시킬 것입니다. "
"어떤 예외가 발생하는 경우, :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` 메소드를 "
"호출해서 모든 변경 사항을 롤백시킬 것입니다. :ref:`editing-buffer` 를 참조하세요."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:625
msgid "Using Spatial Index"
msgstr "공간 인덱스 사용하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:627
msgid ""
"Spatial indexes can dramatically improve the performance of your code if you"
" need to do frequent queries to a vector layer. Imagine, for instance, that "
"you are writing an interpolation algorithm, and that for a given location "
"you need to know the 10 closest points from a points layer, in order to use "
"those point for calculating the interpolated value. Without a spatial index,"
" the only way for QGIS to find those 10 points is to compute the distance "
"from each and every point to the specified location and then compare those "
"distances. This can be a very time consuming task, especially if it needs to"
" be repeated for several locations. If a spatial index exists for the layer,"
" the operation is much more effective."
msgstr ""
"벡터 레이어에 대해 자주 쿼리를 해야 할 경우 공간 인덱스를 사용하면 코드 실행 속도를 획기적으로 향상시킬 수 있습니다. 여러분이 보간 "
"알고리즘을 작성하는데, 보간 값을 계산하기 위해 지정한 위치에서 가장 가까운 포인트 레이어의 포인트 10개를 알아내야 한다고 한번 "
"상상해보십시오. 공간 인덱스가 없다면, QGIS가 그 포인트 10개를 찾는 유일한 방법은 해당 위치에서 모든 포인트까지의 거리를 각각 "
"계산한 다음 그 거리들을 비교하는 것입니다. 특히 이 작업을 몇 군데의 위치에 대해 반복해야 할 경우 시간이 아주 오래 걸릴 수 "
"있습니다. 레이어가 공간 인덱스를 가지고 있다면, 훨씬 효율적으로 작업할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:638
msgid ""
"Think of a layer without a spatial index as a telephone book in which "
"telephone numbers are not ordered or indexed. The only way to find the "
"telephone number of a given person is to read from the beginning until you "
"find it."
msgstr ""
"공간 인덱스가 없는 레이어를 전화번호가 정렬되지도 색인되지도 않은 전화번호부라고 생각해보십시오. 어떤 사람의 전화번호를 찾으려면 처음부터"
" 그 번호를 찾을 때까지 읽을 수밖에 없습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:642
msgid ""
"Spatial indexes are not created by default for a QGIS vector layer, but you "
"can create them easily. This is what you have to do:"
msgstr ""
"QGIS 벡터 레이어에 공간 인덱스를 기본으로 생성하지는 않지만, 쉽게 생성할 수 있습니다. 여러분이 해야 할 일은 다음과 같습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:645
msgid ""
"create spatial index using the :class:`QgsSpatialIndex "
"<qgis.core.QgsSpatialIndex>` class:"
msgstr ""
":class:`QgsSpatialIndex <qgis.core.QgsSpatialIndex>` 클래스를 사용해서 공간 인덱스를 "
"생성합니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:652
msgid ""
"add features to index --- index takes :class:`QgsFeature "
"<qgis.core.QgsFeature>` object and adds it to the internal data structure. "
"You can create the object manually or use one from a previous call to the "
"provider's :meth:`getFeatures() "
"<qgis.core.QgsVectorDataProvider.getFeatures>` method."
msgstr ""
"인덱스에 피처를 추가합니다 --- 인덱스는 :class:`QgsFeature <qgis.core.QgsFeature>` 클래스 객체를 "
"받아 내부 데이터 구조에 추가합니다. 여러분이 객체를 직접 생성할 수도 있고, 또는 제공자의 :meth:`getFeatures() "
"<qgis.core.QgsVectorDataProvider.getFeatures>` 메소드를 호출했을 때 받은 객체를 사용할 수도 "
"있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:661
msgid ""
"alternatively, you can load all features of a layer at once using bulk "
"loading"
msgstr "아니면 벌크 불러오기를 사용해서 레이어의 피처들을 한번에 전부 불러올 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:667
msgid "once spatial index is filled with some values, you can do some queries"
msgstr "공간 인덱스가 값들로 채워지고 나면 쿼리를 해볼 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:677
msgid ""
"You can also use the :class:`QgsSpatialIndexKDBush "
"<qgis.core.QgsSpatialIndexKDBush>` spatial index. This index is similar to "
"the *standard* :class:`QgsSpatialIndex <qgis.core.QgsSpatialIndex>` but:"
msgstr ""
":class:`QgsSpatialIndexKDBush <qgis.core.QgsSpatialIndexKDBush>` 클래스 공간 인덱스도"
" 사용할 수 있습니다. 이 인덱스는 *표준* :class:`QgsSpatialIndex "
"<qgis.core.QgsSpatialIndex>` 클래스 인덱스와 비슷하지만:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:681
msgid "supports **only** single point features"
msgstr "단일 포인트 피처 **만** 지원합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:682
msgid ""
"is **static** (no additional features can be added to the index after the "
"construction)"
msgstr "**정적** 입니다. (인덱스 작성 후에 인덱스에 어떤 피처도 추가할 수 없습니다.)"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:684
msgid "is **much faster!**"
msgstr "**훨씬 빠릅니다!**"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:685
msgid ""
"allows direct retrieval of the original feature’s points, without requiring "
"additional feature requests"
msgstr "추가적인 피처 요청 없이도 원본 피처의 포인트들을 직접 검색할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:687
msgid ""
"supports true *distance based* searches, i.e. return all points within a "
"radius from a search point"
msgstr ""
"예를 들어 검색 포인트로부터 어떤 반경 안에 들어오는 모든 포인트를 반환받는다거나 하는, 진정한 *거리 기반* 검색을 지원합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:693
msgid "The QgsVectorLayerUtils class"
msgstr "QgsVectorLayerUtils 클래스"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:694
msgid ""
"The :class:`QgsVectorLayerUtils <qgis.core.QgsVectorLayerUtils>` class "
"contains some very useful methods that you can use with vector layers."
msgstr ""
":class:`QgsVectorLayerUtils <qgis.core.QgsVectorLayerUtils>` 클래스는 벡터 레이어에 "
"사용할 수 있는 몇몇 매우 유용한 메소드들을 담고 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:697
msgid ""
"For example the :meth:`createFeature() "
"<qgis.core.QgsVectorLayerUtils.createFeature>` method prepares a "
":class:`QgsFeature <qgis.core.QgsFeature>` to be added to a vector layer "
"keeping all the eventual constraints and default values of each field:"
msgstr ""
"예를 들면 :meth:`createFeature() <qgis.core.QgsVectorLayerUtils.createFeature>` "
"메소드는 벡터 레이어에 추가될, 레이어의 각 필드의 모든 최종 제약조건과 기본값을 유지하는 :class:`QgsFeature "
"<qgis.core.QgsFeature>` 클래스를 준비합니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:708
msgid ""
"The :meth:`getValues() <qgis.core.QgsVectorLayerUtils.getValues>` method "
"allows you to quickly get the values of a field or expression:"
msgstr ""
":meth:`getValues() <qgis.core.QgsVectorLayerUtils.getValues>` 메소드는 필드 또는 "
"표현식의 값을 빠르게 얻을 수 있게 해줍니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:727
msgid "Creating Vector Layers"
msgstr "벡터 레이어 생성하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:729
msgid "There are several ways to generate a vector layer dataset:"
msgstr "몇 가지 방법으로 벡터 레이어 데이터셋을 생성할 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:731
msgid ""
"the :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` class: A "
"convenient class for writing vector files to disk, using either a static "
"call to :meth:`writeAsVectorFormatV3() "
"<qgis.core.QgsVectorFileWriter.writeAsVectorFormatV3>` which saves the whole"
" vector layer or creating an instance of the class and issue calls to "
"inherited :meth:`addFeature() <qgis.core.QgsFeatureSink.addFeature>`. This "
"class supports all the vector formats that GDAL supports (GeoPackage, "
"Shapefile, GeoJSON, KML and others)."
msgstr ""
":class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` 클래스: 디스크에 벡터 "
"파일을 작성할 수 있는 편리한 클래스입니다. 전체 벡터 레이어를 저장하는 :meth:`writeAsVectorFormatV3() "
"<qgis.core.QgsVectorFileWriter.writeAsVectorFormatV3>` 메소드를 정적 호출하거나, 클래스의 "
"인스턴스를 생성한 다음 상속한 :meth:`addFeature() <qgis.core.QgsFeatureSink.addFeature>` "
"메소드를 호출합니다. 이 클래스는 GDAL이 지원하는 벡터 포맷들을 모두 (GeoPackage, 셰이프파일, GeoJSON, KML 및 "
"기타 등등) 지원합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:739
msgid ""
"the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` class: instantiates a"
" data provider that interprets the supplied path (url) of the data source to"
" connect to and access the data. It can be used to create temporary, memory-"
"based layers (``memory``) and connect to GDAL vector datasets (``ogr``), "
"databases (``postgres``, ``spatialite``, ``mysql``, ``mssql``) and more "
"(``wfs``, ``gpx``, ``delimitedtext``...)."
msgstr ""
":class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` 클래스: 데이터에 연결하고 접근하기 위한 "
"데이터 소스의 지정 경로(URL)을 해석하는 데이터 제공자를 인스턴스화합니다. 이 클래스를 사용하면 메모리 기반 임시 "
"레이어(``memory``)를 생성하고 GDAL 벡터 데이터셋(``ogr``), 데이터베이스(``postgres``, "
"``spatialite``, ``mysql``, ``mssql``), 그리고 기타 등등(``wfs``, ``gpx``, "
"``delimitedtext``, ...)에 연결할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:748
msgid ""
"From an instance of :class:`QgsVectorFileWriter "
"<qgis.core.QgsVectorFileWriter>`"
msgstr ""
":class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` 클래스의 인스턴스로부터"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:813
msgid ""
"You can also convert fields to make them compatible with different formats "
"by using the  :class:`FieldValueConverter "
"<qgis.core.QgsVectorFileWriter.FieldValueConverter>`. For example, to "
"convert array variable types (e.g. in Postgres) to a text type, you can do "
"the following:"
msgstr ""
"또한 :class:`FieldValueConverter "
"<qgis.core.QgsVectorFileWriter.FieldValueConverter>` 클래스를 사용하면 필드들을 서로 다른 "
"포맷들과 호환되도록 변환할 수 있습니다. 예를 들어 (PostgreSQL에서) 배열 변수 유형을 텍스트 유형으로 변환하려면 다음과 같이 "
"하면 됩니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:850
msgid ""
"A destination CRS may also be specified --- if a valid instance of "
":class:`QgsCoordinateReferenceSystem "
"<qgis.core.QgsCoordinateReferenceSystem>` is passed as the fourth parameter,"
" the layer is transformed to that CRS."
msgstr ""
"대상 좌표를 지정할 수도 있습니다 --- :class:`QgsCoordinateReferenceSystem "
"<qgis.core.QgsCoordinateReferenceSystem>` 클래스의 무결한 인스턴스를 네 번째 파라미터로 전달하면, "
"레이어가 해당 좌표계로 변환됩니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:854
msgid ""
"For valid driver names please call the :meth:`supportedFiltersAndFormats() "
"<qgis.core.QgsVectorFileWriter.supportedFiltersAndFormats>` method or "
"consult the `supported formats by OGR`_ --- you should pass the value in the"
" \"Code\" column as the driver name."
msgstr ""
"무결한 드라이버 이름을 알고 싶다면 :meth:`supportedFiltersAndFormats() "
"<qgis.core.QgsVectorFileWriter.supportedFiltersAndFormats>` 메소드를 호출하거나 "
"`supported formats by OGR`_ (OGR가 지원하는 포맷들) 문서를 살펴보십시오 --- \"Code\" 열에 이 값을 "
"드라이어 이름으로 전달해야 할 것입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:859
msgid ""
"Optionally you can set whether to export only selected features, pass "
"further driver-specific options for creation or tell the writer not to "
"create attributes... There are a number of other (optional) parameters; see "
"the :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` "
"documentation for details."
msgstr ""
"선택한 피처들만 내보낼지, 생성 용 드라이버 전용 심화 옵션들을 전달할지, 작성기에 속성을 생성하지 말라고 할지 등등의 여부를 선택적으로"
" 설정할 수 있습니다. 기타 (선택적) 파라미터들이 여럿 있습니다. 자세한 내용은 :class:`QgsVectorFileWriter "
"<qgis.core.QgsVectorFileWriter>` 클래스 문서를 참조하세요."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:866
msgid "Directly from features"
msgstr "피처로부터 직접"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:919
msgid "From an instance of :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`"
msgstr ":class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` 클래스 인스턴스로부터"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:921
msgid ""
"Among all the data providers supported by the :class:`QgsVectorLayer "
"<qgis.core.QgsVectorLayer>` class, let's focus on the memory-based layers. "
"Memory provider is intended to be used mainly by plugin or 3rd party app "
"developers. It does not store data on disk, allowing developers to use it as"
" a fast backend for some temporary layers."
msgstr ""
":class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` 클래스가 지원하는 모든 데이터 제공자들 "
"가운데, 메모리 기반 레이어를 주목해봅시다. 메모리 제공자는 주로 플러그인이나 제3자 응용 프로그램 개발자들이 사용할 목적으로 "
"설계되었습니다. 메모리 제공자는 디스크 상에 데이터를 저장하지 않기 때문에, 개발자들이 몇몇 임시 레이어에 대한 빠른 백엔드로 사용할 수"
" 있기 때문입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:927
msgid "The provider supports string, int and double fields."
msgstr "이 제공자는 문자열(string), 정수(int), 더블형 실수(double) 유형의 필드를 지원합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:929
msgid ""
"The memory provider also supports spatial indexing, which is enabled by "
"calling the provider's :meth:`createSpatialIndex() "
"<qgis.core.QgsVectorDataProvider.createSpatialIndex>` function. Once the "
"spatial index is created you will be able to iterate over features within "
"smaller regions faster (since it's not necessary to traverse all the "
"features, only those in specified rectangle)."
msgstr ""
"메모리 제공자는 공간 인덱스 작업도 지원하는데, 제공자의 :meth:`createSpatialIndex() "
"<qgis.core.QgsVectorDataProvider.createSpatialIndex>` 함수를 호출하면 됩니다. 공간 인덱스를 "
"생성하고 나면 좁은 지역 안에 있는 피처들을 더 빠르게 반복 작업할 수 있게 될 것입니다. (피처들을 전부 처리할 필요 없이 지정한 "
"직사각형 안에 있는 피처들만 처리하면 되기 때문입니다.)"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:936
msgid ""
"A memory provider is created by passing ``\"memory\"`` as the provider "
"string to the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` "
"constructor."
msgstr ""
":class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` 클래스 작성자(constructor)에 "
"``\"memory\"`` 를 제공자 문자열로 전달하면 메모리 제공자가 생성됩니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:939
msgid ""
"The constructor also takes a URI defining the geometry type of the layer, "
"one of: ``\"Point\"``, ``\"LineString\"``, ``\"Polygon\"``, "
"``\"MultiPoint\"``, ``\"MultiLineString\"``, ``\"MultiPolygon\"`` or "
"``\"None\"``."
msgstr ""
"이 작성자는 레이어의 도형 유형을 정의하는 URI도 받습니다. 도형 유형은 다음 가운데 하나일 수 있습니다: ``\"Point\"``, "
"``\"LineString\"``, ``\"Polygon\"``, ``\"MultiPoint\"``, "
"``\"MultiLineString\"``, ``\"MultiPolygon\"`` or ``\"None\"``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:943
msgid ""
"The URI can also specify the coordinate reference system, fields, and "
"indexing of the memory provider in the URI. The syntax is:"
msgstr "좌표계, 필드, 메모리 기반 제공자의 인덱스 작업도 이 URI로 설정할 수 있습니다. 문법은 다음과 같습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:946
msgid "crs=definition"
msgstr "crs=definition"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:947
msgid ""
"Specifies the coordinate reference system, where definition may be any of "
"the forms accepted by :meth:`QgsCoordinateReferenceSystem.createFromString()"
" <qgis.core.QgsCoordinateReferenceSystem.createFromString>`"
msgstr ""
"좌표계를 지정합니다. 이때 좌표계 정의는 "
":meth:`QgsCoordinateReferenceSystem.createFromString() "
"<qgis.core.QgsCoordinateReferenceSystem.createFromString>` 메소드가 받아들이는 어떤 양식도"
" 될 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:951
msgid "index=yes"
msgstr "index=yes"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:952
msgid "Specifies that the provider will use a spatial index"
msgstr "제공자가 공간 인덱스를 사용하도록 설정합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:954
msgid "field=name:type(length,precision)"
msgstr "field=name:type(length,precision)"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:955
msgid ""
"Specifies an attribute of the layer.  The attribute has a name, and "
"optionally a type (integer, double, or string), length, and precision. There"
" may be multiple field definitions."
msgstr ""
"레이어의 속성을 설정합니다. 속성의 명칭은 필수적이며, 선택적으로 유형(정수, 더블형 실수, 문자 스트링), 길이 및 정밀도를 설정할 수"
" 있습니다. 여러 개의 필드를 정의할 수도 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:959
msgid "The following example of a URI incorporates all these options"
msgstr "다음은 이 모든 옵션들을 포함하는 URI의 예시입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:965
msgid ""
"The following example code illustrates creating and populating a memory "
"provider"
msgstr "다음은 메모리 기반 제공자를 생성하고 값을 채우는 코드의 예시입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:991
msgid "Finally, let's check whether everything went well"
msgstr "마지막으로, 모든 작업이 성공적이었는지 확인해봅시다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1016
msgid "Appearance (Symbology) of Vector Layers"
msgstr "벡터 레이어의 표현(심볼)"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1018
msgid ""
"When a vector layer is being rendered, the appearance of the data is given "
"by **renderer** and **symbols** associated with the layer.  Symbols are "
"classes which take care of drawing of visual representation of features, "
"while renderers determine what symbol will be used for a particular feature."
msgstr ""
"벡터 레이어를 렌더링할 때, 레이어와 관련된 **렌더링 작업자** 와 **심볼** 이 데이터의 표현을 결정합니다. 심볼은 피처의 시각적 "
"표현을 그리는 일을 담당하는 클래스이며, 렌더링 작업자는 특정 피처에 대해 어떤 심볼을 적용할지 결정합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1023
msgid "The renderer for a given layer can be obtained as shown below:"
msgstr "지정한 레이어의 렌더링 작업자는 다음과 같이 얻을 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1029
msgid "And with that reference, let us explore it a bit"
msgstr "그리고 이를 참조해서 조금 더 나가봅시다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1039
msgid ""
"There are several known renderer types available in the QGIS core library:"
msgstr "QGIS 핵심 라이브러리에서 알려진 몇몇 렌더링 작업자 유형을 사용할 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1042
msgid "Type"
msgstr "유형"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1042
msgid "Class"
msgstr "클래스"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1042
msgid "Description"
msgstr "설명"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1044
msgid "singleSymbol"
msgstr "singleSymbol"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1044
msgid ":class:`QgsSingleSymbolRenderer <qgis.core.QgsSingleSymbolRenderer>`"
msgstr ":class:`QgsSingleSymbolRenderer <qgis.core.QgsSingleSymbolRenderer>`"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1044
msgid "Renders all features with the same symbol"
msgstr "모든 피처를 동일한 심볼로 렌더링합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1045
msgid "categorizedSymbol"
msgstr "categorizedSymbol"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1045
msgid ""
":class:`QgsCategorizedSymbolRenderer "
"<qgis.core.QgsCategorizedSymbolRenderer>`"
msgstr ""
":class:`QgsCategorizedSymbolRenderer "
"<qgis.core.QgsCategorizedSymbolRenderer>`"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1045
msgid "Renders features using a different symbol for each category"
msgstr "피처를 각 카테고리 별로 서로 다른 심볼로 렌더링합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1046
msgid "graduatedSymbol"
msgstr "graduatedSymbol"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1046
msgid ""
":class:`QgsGraduatedSymbolRenderer  <qgis.core.QgsGraduatedSymbolRenderer>`"
msgstr ""
":class:`QgsGraduatedSymbolRenderer  <qgis.core.QgsGraduatedSymbolRenderer>`"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1046
msgid "Renders features using a different symbol for each range of values"
msgstr "피처를 값의 범위에 따라 서로 다른 심볼로 렌더링합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1049
msgid ""
"There might be also some custom renderer types, so never make an assumption "
"there are just these types. You can query the application's "
":class:`QgsRendererRegistry <qgis.core.QgsRendererRegistry>` to find out "
"currently available renderers:"
msgstr ""
"몇몇 사용자 정의 렌더링 작업자 유형이 있을 수도 있기 때문에, 이 유형들만 있을 거라고 절대로 가정하지 마십시오. 현재 사용할 수 있는"
" 렌더링 작업자들을 알아내려면 응용 프로그램의 :class:`QgsRendererRegistry "
"<qgis.core.QgsRendererRegistry>` 클래스를 쿼리하면 됩니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1061
msgid ""
"It is possible to obtain a dump of a renderer contents in text form --- can "
"be useful for debugging"
msgstr "렌더링 작업자의 콘텐츠를 텍스트 형식으로 덤프받을 수도 있습니다 --- 디버깅 작업에 유용할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1075
msgid "Single Symbol Renderer"
msgstr "단일 심볼 렌더링 작업자"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1077
msgid ""
"You can get the symbol used for rendering by calling :meth:`symbol() "
"<qgis.core.QgsSingleSymbolRenderer.symbol>` method and change it with "
":meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` method "
"(note for C++ devs: the renderer takes ownership of the symbol.)"
msgstr ""
":meth:`symbol() <qgis.core.QgsSingleSymbolRenderer.symbol>` 메소드를 호출하면 렌더링에 "
"쓰인 심볼을 가져올 수 있고, :meth:`setSymbol() "
"<qgis.core.QgsSingleSymbolRenderer.setSymbol>` 메소드로 심볼을 변경할 수 있습니다. (C++ "
"개발자는 기억하세요: 렌더링 작업자가 심볼을 소유합니다.)"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1081
msgid ""
"You can change the symbol used by a particular vector layer by calling "
":meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` passing an"
" instance of the appropriate symbol instance. Symbols for *point*, *line* "
"and *polygon* layers can be created by calling the :meth:`createSimple() "
"<qgis.core.QgsMarkerSymbol.createSimple>` function of the corresponding "
"classes :class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>`, "
":class:`QgsLineSymbol <qgis.core.QgsLineSymbol>` and :class:`QgsFillSymbol "
"<qgis.core.QgsFillSymbol>`."
msgstr ""
":meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` 메소드를 호출해서 "
"적당한 심볼의 인스턴스를 전달하면 특정 벡터 레이어가 사용하는 심볼을 변경할 수 있습니다. :class:`QgsMarkerSymbol "
"<qgis.core.QgsMarkerSymbol>`, :class:`QgsLineSymbol "
"<qgis.core.QgsLineSymbol>`, 그리고 :class:`QgsFillSymbol "
"<qgis.core.QgsFillSymbol>` 클래스의 각각 대응하는 :meth:`createSimple() "
"<qgis.core.QgsMarkerSymbol.createSimple>` 함수를 호출하면 각각 *포인트*, *라인*, *폴리곤* 레이어"
" 용 심볼을 생성할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1088
msgid ""
"The dictionary passed to :meth:`createSimple() "
"<qgis.core.QgsMarkerSymbol.createSimple>` sets the style properties of the "
"symbol."
msgstr ""
":meth:`createSimple() <qgis.core.QgsMarkerSymbol.createSimple>` 메소드에 전달되는 "
"목록(dictionary)이 심볼의 스타일 속성을 설정합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1091
msgid ""
"For example you can replace the symbol used by a particular **point** layer "
"by calling :meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>`"
" passing an instance of a :class:`QgsMarkerSymbol "
"<qgis.core.QgsMarkerSymbol>`, as in the following code example:"
msgstr ""
"예를 들면 다음 코드 예시와 같이 :meth:`setSymbol() "
"<qgis.core.QgsSingleSymbolRenderer.setSymbol>` 메소드를 호출해서 "
":class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>` 클래스의 인스턴스를 전달하면, 특정 "
"**포인트** 레이어가 사용하는 심볼을 대체시킬 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1102
msgid ""
"``name`` indicates the shape of the marker, and can be any of the following:"
msgstr "``name`` 은 마커의 형태를 의미하며, 다음 중 어느 것이라도 가능합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1104
msgid "``circle``"
msgstr "``circle``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1105
msgid "``square``"
msgstr "``square``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1106
msgid "``cross``"
msgstr "``cross``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1107
msgid "``rectangle``"
msgstr "``rectangle``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1108
msgid "``diamond``"
msgstr "``diamond``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1109
msgid "``pentagon``"
msgstr "``pentagon``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1110
msgid "``triangle``"
msgstr "``triangle``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1111
msgid "``equilateral_triangle``"
msgstr "``equilateral_triangle``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1112
msgid "``star``"
msgstr "``star``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1113
msgid "``regular_star``"
msgstr "``regular_star``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1114
msgid "``arrow``"
msgstr "``arrow``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1115
msgid "``filled_arrowhead``"
msgstr "``filled_arrowhead``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1116
msgid "``x``"
msgstr "``x``"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1119
msgid ""
"To get the full list of properties for the first symbol layer of a symbol "
"instance you can follow the example code:"
msgstr "심볼 인스턴스의 첫 번째 심볼 레이어에 대한 전체 속성 목록을 알고 싶다면 다음 코드 예시를 따라해보십시오:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1130
msgid "This can be useful if you want to alter some properties:"
msgstr "여러분이 속성을 일부 변경하고 싶다면 다음이 유용할 것입니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1149
msgid "Categorized Symbol Renderer"
msgstr "카테고리 심볼 렌더링 작업자"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1151
msgid ""
"When using a categorized renderer, you can query and set the attribute that "
"is used for classification: use the :meth:`classAttribute() "
"<qgis.core.QgsCategorizedSymbolRenderer.classAttribute>` and "
":meth:`setClassAttribute() "
"<qgis.core.QgsCategorizedSymbolRenderer.setClassAttribute>` methods."
msgstr ""
"카테고리 렌더링 작업자를 사용할 때, 범주화에 사용되는 속성을 쿼리하고 설정할 수 있습니다: :meth:`classAttribute() "
"<qgis.core.QgsCategorizedSymbolRenderer.classAttribute>` 및 "
":meth:`setClassAttribute() "
"<qgis.core.QgsCategorizedSymbolRenderer.setClassAttribute>` 메소드를 사용하십시오."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1154
msgid "To get a list of categories"
msgstr "카테고리 목록을 얻는 방법은 다음과 같습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1175
msgid ""
"Where :meth:`value() <qgis.core.QgsRendererCategory.value>` is the value "
"used for discrimination between categories, :meth:`label() "
"<qgis.core.QgsRendererCategory.label>` is a text used for category "
"description and :meth:`symbol() <qgis.core.QgsRendererCategory.symbol>` "
"method returns the assigned symbol."
msgstr ""
"이때 :meth:`value() <qgis.core.QgsRendererCategory.value>` 메소드가 카테고리들을 구분하는 데 "
"쓰이는 값이고, :meth:`label() <qgis.core.QgsRendererCategory.label>` 메소드는 카테고리 설명에"
" 쓰이는 텍스트이며, :meth:`symbol() <qgis.core.QgsRendererCategory.symbol>` 메소드는 할당된"
" 심볼을 반환합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1179
msgid ""
"The renderer usually stores also original symbol and color ramp which were "
"used for the classification: :meth:`sourceColorRamp() "
"<qgis.core.QgsCategorizedSymbolRenderer.sourceColorRamp>` and "
":meth:`sourceSymbol() <qgis.core.QgsCategorizedSymbolRenderer.sourceSymbol>`"
" methods."
msgstr ""
"이 렌더링 작업자는 일반적으로 범주화에 사용된 원본 심볼과 색상표도 저장합니다: :meth:`sourceColorRamp() "
"<qgis.core.QgsCategorizedSymbolRenderer.sourceColorRamp>` 및 "
":meth:`sourceSymbol() <qgis.core.QgsCategorizedSymbolRenderer.sourceSymbol>`"
" 메소드를 사용하십시오."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1185
msgid "Graduated Symbol Renderer"
msgstr "등급 심볼 렌더링 작업자"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1187
msgid ""
"This renderer is very similar to the categorized symbol renderer described "
"above, but instead of one attribute value per class it works with ranges of "
"values and thus can be used only with numerical attributes."
msgstr ""
"이 렌더링 작업자는 앞에서 설명한 카테고리 심볼 렌더링 작업자와 매우 비슷하지만, 범주 당 하나의 속성을 할당하는 대신 값의 범위에 따라"
" 할당하기 때문에 숫자 속성에만 사용할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1191
msgid "To find out more about ranges used in the renderer"
msgstr "이 렌더링 작업자가 사용하는 범위에 대해 상세히 알아내려면 다음과 같은 방법을 사용합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1214
msgid ""
"you can again use the :meth:`classAttribute() "
"<qgis.core.QgsGraduatedSymbolRenderer.classAttribute>` (to find the "
"classification attribute name), :meth:`sourceSymbol() "
"<qgis.core.QgsGraduatedSymbolRenderer.sourceSymbol>` and "
":meth:`sourceColorRamp() "
"<qgis.core.QgsGraduatedSymbolRenderer.sourceColorRamp>` methods. "
"Additionally there is the :meth:`mode() "
"<qgis.core.QgsGraduatedSymbolRenderer.mode>` method which determines how the"
" ranges were created: using equal intervals, quantiles or some other method."
msgstr ""
"(범주화 속성 이름을 알아내기 위한) :meth:`classAttribute() "
"<qgis.core.QgsGraduatedSymbolRenderer.classAttribute>` 메소드와 "
":meth:`sourceSymbol() <qgis.core.QgsGraduatedSymbolRenderer.sourceSymbol>` 및"
" :meth:`sourceColorRamp() "
"<qgis.core.QgsGraduatedSymbolRenderer.sourceColorRamp>` 메소드를 다시 사용하면 됩니다. 범위"
" 생성 방법을 결정하는 추가적인 :meth:`mode() <qgis.core.QgsGraduatedSymbolRenderer.mode>`"
" 메소드도 있습니다: 등간격을 사용할지, 사분위를 사용할지, 또는 기타 다른 방법을 사용할지 결정할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1223
msgid ""
"If you wish to create your own graduated symbol renderer you can do so as "
"illustrated in the example snippet below (which creates a simple two class "
"arrangement)"
msgstr ""
"사용자 정의 등급 심볼 렌더링 작업자를 생성하고자 할 경우 다음 예시에서처럼 하면 됩니다. (이 예시에서는 범주 2개인 간단한 배열을 "
"생성합니다.)"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1267
msgid "Working with Symbols"
msgstr "심볼 다루기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1269
msgid ""
"For representation of symbols, there is :class:`QgsSymbol "
"<qgis.core.QgsSymbol>` base class with three derived classes:"
msgstr ""
"심볼을 표현하기 위한 :class:`QgsSymbol <qgis.core.QgsSymbol>` 기저(base) 클래스는 파생 클래스 "
"3개를 가지고 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1272
msgid ""
":class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>` --- for point features"
msgstr ":class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>` --- 포인트 피처 용"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1273
msgid ":class:`QgsLineSymbol <qgis.core.QgsLineSymbol>` --- for line features"
msgstr ":class:`QgsLineSymbol <qgis.core.QgsLineSymbol>` --- 라인 피처 용"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1274
msgid ""
":class:`QgsFillSymbol <qgis.core.QgsFillSymbol>` --- for polygon features"
msgstr ":class:`QgsFillSymbol <qgis.core.QgsFillSymbol>` --- 폴리곤 피처 용"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1276
msgid ""
"**Every symbol consists of one or more symbol layers** (classes derived from"
" :class:`QgsSymbolLayer <qgis.core.QgsSymbolLayer>`). The symbol layers do "
"the actual rendering, the symbol class itself serves only as a container for"
" the symbol layers."
msgstr ""
"**모든 심볼은 하나 이상의** (:class:`QgsSymbolLayer <qgis.core.QgsSymbolLayer>` 클래스에서 "
"파생된 클래스인) **심볼 레이어로 이루어집니다**. 이 심볼 레이어들이 실제 렌더링 작업을 하며, 심볼 클래스 자체는 심볼 레이어 용 "
"컨테이너 역할만 합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1280
msgid ""
"Having an instance of a symbol (e.g. from a renderer), it is possible to "
"explore it: the :meth:`type() <qgis.core.QgsSymbol.type>` method says "
"whether it is a marker, line or fill symbol. There is a :meth:`dump() "
"<qgis.core.QgsSymbol.dump>` method which returns a brief description of the "
"symbol. To get a list of symbol layers:"
msgstr ""
"(예를 들어 렌더링 작업자로부터 나온) 심볼 인스턴스를 가지고 있다면, 심볼을 탐색해볼 수 있습니다: :meth:`type() "
"<qgis.core.QgsSymbol.type>` 메소드는 심볼이 마커, 라인, 또는 채우기 심볼 가운데 어떤 유형인지 알려줍니다. "
"심볼의 짧은 설명을 반환하는 :meth:`dump() <qgis.core.QgsSymbol.dump>` 메소드도 있습니다. 심볼 레이어 "
"목록을 보고 싶다면:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1297
msgid ""
"To find out symbol's color use :meth:`color() <qgis.core.QgsSymbol.color>` "
"method and :meth:`setColor() <qgis.core.QgsSymbol.setColor>` to change its "
"color. With marker symbols additionally you can query for the symbol size "
"and rotation with the :meth:`size() <qgis.core.QgsMarkerSymbol.size>` and "
":meth:`angle() <qgis.core.QgsMarkerSymbol.angle>` methods. For line symbols "
"the :meth:`width() <qgis.core.QgsLineSymbol.width>` method returns the line "
"width."
msgstr ""
"심볼의 색상을 알아내려면 :meth:`color() <qgis.core.QgsSymbol.color>` 메소드를 사용하고 그 색상을 "
"변경하려면 :meth:`setColor() <qgis.core.QgsSymbol.setColor>` 메소드를 사용하십시오. 마커 심볼의 "
"경우 추가적으로 :meth:`size() <qgis.core.QgsMarkerSymbol.size>` 와 :meth:`angle() "
"<qgis.core.QgsMarkerSymbol.angle>` 메소드를 사용해서 각각 심볼 크기와 회전 각도를 쿼리할 수 있습니다. 라인"
" 심볼의 경우 :meth:`width() <qgis.core.QgsLineSymbol.width>` 메소드가 라인 너비를 반환합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1304
msgid "Size and width are in millimeters by default, angles are in degrees."
msgstr "기본적으로 크기 및 너비는 밀리미터 단위이며, 각도는 도 단위입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1309
msgid "Working with Symbol Layers"
msgstr "심볼 레이어 다루기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1311
msgid ""
"As said before, symbol layers (subclasses of :class:`QgsSymbolLayer "
"<qgis.core.QgsSymbolLayer>`) determine the appearance of the features.  "
"There are several basic symbol layer classes for general use. It is possible"
" to implement new symbol layer types and thus arbitrarily customize how "
"features will be rendered. The :meth:`layerType() "
"<qgis.core.QgsSymbolLayer.layerType>` method uniquely identifies the symbol "
"layer class --- the basic and default ones are ``SimpleMarker``, "
"``SimpleLine`` and ``SimpleFill`` symbol layers types."
msgstr ""
"앞에서 말했듯이, (:class:`QgsSymbolLayer <qgis.core.QgsSymbolLayer>` 클래스의 하위 클래스인) "
"심볼 레이어가 피처의 모양을 결정합니다. 일반적인 사용례를 위한 기본 심볼 레이어 클래스가 몇 개 있습니다. 새로운 심볼 레이어 유형을 "
"구현할 수 있기 때문에, 사용자가 피처를 어떻게 렌더링할지를 임의로 정의할 수 있습니다. :meth:`layerType() "
"<qgis.core.QgsSymbolLayer.layerType>` 메소드가 심볼 레이어 클래스를 고유하게 식별합니다 --- 기본 "
"클래스는 ``SimpleMarker``, ``SimpleLine`` 및 ``SimpleFill`` 심볼 레이어 유형입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1318
msgid ""
"You can get a complete list of the types of symbol layers you can create for"
" a given symbol layer class with the following code:"
msgstr "지정한 심볼 레이어 클래스에 생성할 수 있는 심볼 레이어 유형들의 전체 리스트를 다음 코드로 볼 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1342
msgid ""
"The :class:`QgsSymbolLayerRegistry <qgis.core.QgsSymbolLayerRegistry>` class"
" manages a database of all available symbol layer types."
msgstr ""
":class:`QgsSymbolLayerRegistry <qgis.core.QgsSymbolLayerRegistry>` 클래스는 사용할 "
"수 있는 모든 레이어 유형들의 데이터베이스를 관리합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1345
msgid ""
"To access symbol layer data, use its :meth:`properties() "
"<qgis.core.QgsSymbolLayer.properties>` method that returns a key-value "
"dictionary of properties which determine the appearance. Each symbol layer "
"type has a specific set of properties that it uses. Additionally, there are "
"the generic methods :meth:`color() <qgis.core.QgsSymbol.color>`, "
":meth:`size() <qgis.core.QgsMarkerSymbol.size>`, :meth:`angle() "
"<qgis.core.QgsMarkerSymbol.angle>` and :meth:`width() "
"<qgis.core.QgsLineSymbol.width>`, with their setter counterparts. Of course "
"size and angle are available only for marker symbol layers and width for "
"line symbol layers."
msgstr ""
"심볼 레이어 데이터에 접근하려면, 심볼 모양을 결정하는 속성들의 키-값 목록(dictionary)을 반환하는 "
":meth:`properties() <qgis.core.QgsSymbolLayer.properties>` 메소드를 사용하십시오. 각각의 "
"심볼 레이어 유형은 해당 유형이 사용하는 특정한 속성 집합을 가지고 있습니다. 또한 각각의 설정자(setter) 대응 항목을 가진 "
"일반적인 :meth:`color() <qgis.core.QgsSymbol.color>`, :meth:`size() "
"<qgis.core.QgsMarkerSymbol.size>`, :meth:`angle() "
"<qgis.core.QgsMarkerSymbol.angle>` 및 :meth:`width() "
"<qgis.core.QgsLineSymbol.width>` 메소드들도 있습니다. 물론 크기와 각도는 마커 심볼에만 사용할 수 있으며 "
"너비는 라인 심볼에만 사용할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1357
msgid "Creating Custom Symbol Layer Types"
msgstr "사용자 지정 심볼 레이어 유형 생성하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1359
msgid ""
"Imagine you would like to customize the way how the data gets rendered. You "
"can create your own symbol layer class that will draw the features exactly "
"as you wish. Here is an example of a marker that draws red circles with "
"specified radius"
msgstr ""
"데이터를 어떻게 렌더링할지 사용자 정의하고 싶다고 상상해보십시오. 사용자가 원하는 방식대로 피처를 그리는, 자신만의 심볼 레이어 클래스를"
" 생성할 수 있습니다. 다음 코드는 지정된 반경으로 빨간색 원을 그리는 마커의 예시입니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1399
msgid ""
"The :meth:`layerType() <qgis.core.QgsSymbolLayer.layerType>` method "
"determines the name of the symbol layer; it has to be unique among all "
"symbol layers. The :meth:`properties() "
"<qgis.core.QgsSymbolLayer.properties>` method is used for persistence of "
"attributes. The :meth:`clone() <qgis.core.QgsSymbolLayer.clone>` method must"
" return a copy of the symbol layer with all attributes being exactly the "
"same. Finally there are rendering methods: :meth:`startRender() "
"<qgis.core.QgsSymbolLayer.startRender>` is called before rendering the first"
" feature, :meth:`stopRender() <qgis.core.QgsSymbolLayer.stopRender>` when "
"the rendering is done, and :meth:`renderPoint() "
"<qgis.core.QgsMarkerSymbolLayer.renderPoint>` is called to do the rendering."
" The coordinates of the point(s) are already transformed to the output "
"coordinates."
msgstr ""
":meth:`layerType() <qgis.core.QgsSymbolLayer.layerType>` 메소드가 심볼 레이어의 이름을 "
"결정합니다. 이 이름은 전체 심볼 레이어들 사이에서 유일해야 합니다. :meth:`properties() "
"<qgis.core.QgsSymbolLayer.properties>` 메소드는 속성들의 지속성을 위해 쓰입니다. "
":meth:`clone() <qgis.core.QgsSymbolLayer.clone>` 메소드는 반드시 심볼 레이어와 모든 속성이 "
"정확하게 동일한 복제물을 반환해야만 합니다. 마지막으로 렌더링 메소드들이 있습니다: 첫 번째 피처를 렌더링하기 전에 "
":meth:`startRender() <qgis.core.QgsSymbolLayer.startRender>` 메소드를 호출하고, 렌더링을"
" 완료했을 때 :meth:`stopRender() <qgis.core.QgsSymbolLayer.stopRender>` 메소드를 "
"호출하며, 렌더링을 하기 위해서는 :meth:`renderPoint() "
"<qgis.core.QgsMarkerSymbolLayer.renderPoint>` 메소드를 호출합니다. 포인트(들)의 좌표는 이미 산출 "
"좌표로 변환되어 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1411
msgid ""
"For polylines and polygons the only difference would be in the rendering "
"method: you would use :meth:`renderPolyline() "
"<qgis.core.QgsLineSymbolLayer.renderPolyline>` which receives a list of "
"lines, while :meth:`renderPolygon() "
"<qgis.core.QgsFillSymbolLayer.renderPolygon>` receives a list of points on "
"the outer ring as the first parameter and a list of inner rings (or None) as"
" a second parameter."
msgstr ""
"폴리라인 및 폴리곤의 경우 유일한 차이점은 렌더링 메소드에 있을 것입니다: 라인의 경우 라인 목록을 받는 "
":meth:`renderPolyline() <qgis.core.QgsLineSymbolLayer.renderPolyline>` 메소드를 "
"사용하는 반면, 폴리곤의 경우 외곽 고리 상에 있는 포인트 목록을 첫 번째 파라미터로 그리고 내곽 고리의 포인트 목록(또는 None)을 "
"두 번째 파라미터로 받는 :meth:`renderPolygon() "
"<qgis.core.QgsFillSymbolLayer.renderPolygon>` 메소드를 사용할 것입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1419
msgid ""
"Usually it is convenient to add a GUI for setting attributes of the symbol "
"layer type to allow users to customize the appearance: in case of our "
"example above we can let user set circle radius. The following code "
"implements such widget"
msgstr ""
"일반적으로 사용자가 모양을 변경할 수 있도록 심볼 레이어 유형의 속성을 설정하기 위한 GUI를 추가하는 편이 좋습니다. 앞의 예시에서 "
"사용자가 원의 반경을 설정하도록 할 수 있습니다. 다음 코드는 그런 위젯을 구현하는 예시입니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1457
msgid ""
"This widget can be embedded into the symbol properties dialog. When the "
"symbol layer type is selected in symbol properties dialog, it creates an "
"instance of the symbol layer and an instance of the symbol layer widget. "
"Then it calls the :meth:`setSymbolLayer() "
"<qgis.gui.QgsSymbolLayerWidget.setSymbolLayer>` method to assign the symbol "
"layer to the widget. In that method the widget should update the UI to "
"reflect the attributes of the symbol layer. The :meth:`symbolLayer() "
"<qgis.gui.QgsSymbolLayerWidget.symbolLayer>` method is used to retrieve the "
"symbol layer again by the properties dialog to use it for the symbol."
msgstr ""
"심볼 속성 대화창 안에 이 위젯을 내장시킬 수 있습니다. 심볼 속성 대화창에서 심볼 레이어 유형을 선택했을 때, 심볼 레이어의 인스턴스 "
"및 심볼 레이어 위젯의 인스턴스를 생성합니다. 그 다음 :meth:`setSymbolLayer() "
"<qgis.gui.QgsSymbolLayerWidget.setSymbolLayer>` 메소드를 호출해서 위젯에 심볼 레이어를 할당합니다."
" 이때 위젯이 심볼 레이어의 속성을 반영하도록 UI를 업데이트해야 합니다. 심볼 속성 대화창에서 심볼에 사용할 수 있도록 심볼 레이어를 "
"다시 검색하는 데 :meth:`symbolLayer() <qgis.gui.QgsSymbolLayerWidget.symbolLayer>` "
"메소드를 사용합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1467
msgid ""
"On every change of attributes, the widget should emit the :any:`changed() "
"<qgis.gui.QgsSymbolLayerWidget.changed>` signal to let the properties dialog"
" update the symbol preview."
msgstr ""
"속성을 변경할 때마다, 이 위젯은 심볼 속성 대화창이 심볼 미리보기를 업데이트할 수 있도록 :any:`changed() "
"<qgis.gui.QgsSymbolLayerWidget.changed>` 신호를  보내야 합니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1471
msgid ""
"Now we are missing only the final glue: to make QGIS aware of these new "
"classes. This is done by adding the symbol layer to registry. It is possible"
" to use the symbol layer also without adding it to the registry, but some "
"functionality will not work: e.g. loading of project files with the custom "
"symbol layers or inability to edit the layer's attributes in GUI."
msgstr ""
"이제 마지막 단계만 남았습니다. QGIS가 이 새 클래스들을 인식하도록 심볼 레이어를 레지스트리에 추가하는 일입니다. 심볼 레이어를 "
"레지스트리에 추가하지 않고 사용할 수도 있지만, 예를 들어 사용자 정의 심볼 레이어를 담고 있는 프로젝트 파일을 불러오지 못한다든가 "
"GUI에서 레이어 속성을 편집할 수 없다는 등 몇몇 기능들을 사용할 수 없게 됩니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1477
msgid "We will have to create metadata for the symbol layer"
msgstr "심볼 레이어에 대한 메타데이터도 생성해야 합니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1498
msgid ""
"You should pass layer type (the same as returned by the layer) and symbol "
"type (marker/line/fill) to the constructor of the parent class. The "
":meth:`createSymbolLayer() "
"<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayer>` method takes "
"care of creating an instance of symbol layer with attributes specified in "
"the `props` dictionary. And there is the :meth:`createSymbolLayerWidget() "
"<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayerWidget>` method "
"which returns the settings widget for this symbol layer type."
msgstr ""
"상위 클래스의 작성자에 (레이어가 반환하는 유형과 동일한) 레이어 유형과 심볼 유형(마커/라인/채우기)을 전달해야 합니다. "
":meth:`createSymbolLayer() "
"<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayer>` 메소드가 ``props``"
" 목록(dictionary)에 지정된 속성들을 가진 심볼 레이어의 인스턴스 생성을 처리합니다. 그리고 해당 심볼 레이어 유형을 위한 설정"
" 위젯을 반환하는 :meth:`createSymbolLayerWidget() "
"<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayerWidget>` 메소드도 "
"있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1506
msgid ""
"The last step is to add this symbol layer to the registry --- and we are "
"done."
msgstr "마지막 단계는 레지스트리에 이 심볼 레이어를 추가하는 일입니다. 이제 모두 끝났습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1512
msgid "Creating Custom Renderers"
msgstr "사용자 정의 렌더링 작업자 생성하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1514
msgid ""
"It might be useful to create a new renderer implementation if you would like"
" to customize the rules how to select symbols for rendering of features. "
"Some use cases where you would want to do it: symbol is determined from a "
"combination of fields, size of symbols changes depending on current scale "
"etc."
msgstr ""
"피처를 렌더링하는 데 어떻게 심볼을 선택할지에 대한 규칙을 마음대로 지정하고 싶을 경우 새로운 렌더링 작업자를 만드는 편이 유용할 수도 "
"있습니다. 여러 필드들을 조합해서 심볼을 결정해야 하거나, 현재 축척에 따라 심볼 크기를 변경해야 하는 등의 경우에 새로운 렌더링 "
"작업자를 만들면 좋습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1519
msgid ""
"The following code shows a simple custom renderer that creates two marker "
"symbols and chooses randomly one of them for every feature"
msgstr ""
"다음 코드는 마커 심볼 2개를 생성해서 각 피처마다 랜덤하게 2개 중 1개를 할당하는 간단한 사용자 정의 렌더링 작업자의 예시입니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1555
msgid ""
"The constructor of the parent :class:`QgsFeatureRenderer "
"<qgis.core.QgsFeatureRenderer>` class needs a renderer name (which has to be"
" unique among renderers). The :meth:`symbolForFeature() "
"<qgis.core.QgsFeatureRenderer.symbolForFeature>` method is the one that "
"decides what symbol will be used for a particular feature. "
":meth:`startRender() <qgis.core.QgsFeatureRenderer.startRender>` and "
":meth:`stopRender() <qgis.core.QgsFeatureRenderer.stopRender>` take care of "
"initialization/finalization of symbol rendering. The :meth:`usedAttributes()"
" <qgis.core.QgsFeatureRenderer.usedAttributes>` method can return a list of "
"field names that the renderer expects to be present. Finally, the "
":meth:`clone() <qgis.core.QgsFeatureRenderer.clone>` method should return a "
"copy of the renderer."
msgstr ""
"상위 :class:`QgsFeatureRenderer <qgis.core.QgsFeatureRenderer>` 클래스의 작성자는 (렌더링"
" 작업자들 가운데 유일해야 하는) 렌더링 작업자 이름을 필요로 합니다. :meth:`symbolForFeature() "
"<qgis.core.QgsFeatureRenderer.symbolForFeature>` 가 특정 피처에 어떤 심볼을 사용할지 결정하는 "
"메소드입니다. :meth:`startRender() <qgis.core.QgsFeatureRenderer.startRender>` 와 "
":meth:`stopRender() <qgis.core.QgsFeatureRenderer.stopRender>` 메소드는 각각 심볼 "
"렌더링 작업의 시작과 마무리를 처리합니다. :meth:`usedAttributes() "
"<qgis.core.QgsFeatureRenderer.usedAttributes>` 메소드는 렌더링 작업자가 존재할 것으로 예상하는 필드"
" 이름 목록을 반환할 수 있습니다. 마지막으로 :meth:`clone() "
"<qgis.core.QgsFeatureRenderer.clone>` 메소드는 렌더링 작업자의 복제물을 반환할 것입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1566
msgid ""
"Like with symbol layers, it is possible to attach a GUI for configuration of"
" the renderer. It has to be derived from :class:`QgsRendererWidget "
"<qgis.gui.QgsRendererWidget>`. The following sample code creates a button "
"that allows the user to set the first symbol"
msgstr ""
"심볼 레이어와 마찬가지로, 렌더링 작업자를 환경설정하기 위한 GUI를 추가할 수 있습니다. 이 GUI는 "
":class:`QgsRendererWidget <qgis.gui.QgsRendererWidget>` 클래스로부터 파생시켜야 합니다. 다음"
" 코드는 여러분이 첫 번째 심볼을 설정할 수 있게 해주는 버튼을 생성하는 예시입니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1600
msgid ""
"The constructor receives instances of the active layer "
"(:class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`), the global style "
"(:class:`QgsStyle <qgis.core.QgsStyle>`) and the current renderer. If there "
"is no renderer or the renderer has different type, it will be replaced with "
"our new renderer, otherwise we will use the current renderer (which has "
"already the type we need). The widget contents should be updated to show "
"current state of the renderer. When the renderer dialog is accepted, the "
"widget's :meth:`renderer() <qgis.gui.QgsRendererWidget.renderer>` method is "
"called to get the current renderer --- it will be assigned to the layer."
msgstr ""
"이 작성자는 활성 레이어의 인스턴스(:class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`), 전체 "
"수준 스타일(:class:`QgsStyle <qgis.core.QgsStyle>`), 그리고 현재 렌더링 작업자를 받습니다. 렌더링 "
"작업자가 없거나 렌더링 작업자가 다른 유형인 경우, 새로운 사용자 정의 렌더링 작업자로 대체할 것입니다. 그렇지 않은 경우 (이미 필요한"
" 유형인) 현재 렌더링 작업자를 사용할 것입니다. 렌더링 작업자의 현재 상태를 보이도록 위젯의 내용을 업데이트해야 합니다. 렌더링 작업자"
" 대화창이 승인되면, 현재 렌더링 작업자를 가져오기 위해 위젯의 :meth:`renderer() "
"<qgis.gui.QgsRendererWidget.renderer>` 메소드를 호출합니다 --- 레이어에 가져온 렌더링 작업자를 할당할 "
"것입니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1610
msgid ""
"The last missing bit is the renderer metadata and registration in registry, "
"otherwise loading of layers with the renderer will not work and user will "
"not be able to select it from the list of renderers. Let us finish our "
"RandomRenderer example"
msgstr ""
"마지막으로 렌더링 작업자의 메타데이터를 생성하고 레지스트리에 렌더링 작업자를 등록해야 합니다. 이렇게 하지 않으면 렌더링 작업자와 함께 "
"레이어를 불러올 수 없고, 사용자가 렌더링 작업자 목록에서 렌더링 작업자를 선택할 수 없습니다. 이제 "
":class:`RandomRenderer` 예시 코드를 완성해봅시다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1640
msgid ""
"Similarly as with symbol layers, abstract metadata constructor awaits "
"renderer name, name visible for users and optionally name of renderer's "
"icon. The :meth:`createRenderer() "
"<qgis.core.QgsRendererAbstractMetadata.createRenderer>` method passes a "
":class:`QDomElement` instance that can be used to restore the renderer's "
"state from the DOM tree. The :meth:`createRendererWidget() "
"<qgis.core.QgsRendererAbstractMetadata.createRendererWidget>` method creates"
" the configuration widget. It does not have to be present or can return "
"``None`` if the renderer does not come with GUI."
msgstr ""
"심볼 레이어의 경우와 비슷하게, 추상(abstract) 메타데이터 작성자도 렌더링 작업자 이름, 여러분이 볼 수 있는 이름, 그리고 "
"선택적인 렌더링 작업자의 아이콘 이름을 기다립니다. :meth:`createRenderer() "
"<qgis.core.QgsRendererAbstractMetadata.createRenderer>` 메소드가 DOM 트리로부터 렌더링 "
"작업자의 상태를 복구하는 데 사용할 수 있는 :class:`QDomElement` 클래스 인스턴스를 전달합니다. "
":meth:`createRendererWidget() "
"<qgis.core.QgsRendererAbstractMetadata.createRendererWidget>` 메소드는 환경설정 위젯을 "
"생성합니다. 렌더링 작업자가 GUI를 가지고 있지 않은 경우, 이 메소드를 사용할 필요가 없고 또는 이 메소드가 ``None`` 을 "
"반환할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1649
msgid ""
"To associate an icon with the renderer you can assign it in the "
":class:`QgsRendererAbstractMetadata <qgis.core.QgsRendererAbstractMetadata>`"
" constructor as a third (optional) argument --- the base class constructor "
"in the RandomRendererMetadata :func:`__init__` function becomes"
msgstr ""
"렌더링 작업자에 아이콘을 연결하려면 :class:`QgsRendererAbstractMetadata "
"<qgis.core.QgsRendererAbstractMetadata>` 작성자에 아이콘을 세 번째 (선택적) 인자로 할당하면 됩니다 "
"--- RandomRendererMetadata :func:`__init__` 함수에 있는 기저 클래스 작성자는 다음과 같이 보일 "
"것입니다:"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1663
msgid ""
"The icon can also be associated at any later time using the :meth:`setIcon()"
" <qgis.core.QgsRendererAbstractMetadata.setIcon>` method of the metadata "
"class. The icon can be loaded from a file (as shown above) or can be loaded "
"from a `Qt resource <https://doc.qt.io/qt-5/resources.html>`_ (PyQt5 "
"includes .qrc compiler for Python)."
msgstr ""
"메타데이터 클래스의 :meth:`setIcon() <qgis.core.QgsRendererAbstractMetadata.setIcon>`"
" 메소드를 사용하면 이후 어느 때에라도 아이콘을 연결시킬 수 있습니다. 이 아이콘은 (앞에서 볼 수 있듯이) 파일에서 불러올 수도 있고,"
" 또는 `Qt 리소스 <https://doc.qt.io/qt-5/resources.html>`_ 에서 불러올 수도 있습니다. "
"(PyQt5는 파이썬 용 .qrc 컴파일러를 포함하고 있습니다.)"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1671
msgid "Further Topics"
msgstr "남은 이야기들"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1674
msgid "**TODO:**"
msgstr "**할 일:**"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1676
msgid "creating/modifying symbols"
msgstr "심볼 생성/수정하기"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1677
msgid "working with style (:class:`QgsStyle <qgis.core.QgsStyle>`)"
msgstr "스타일 작업하기 (:class:`QgsStyle <qgis.core.QgsStyle>` 클래스)"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1678
msgid ""
"working with color ramps (:class:`QgsColorRamp <qgis.core.QgsColorRamp>`)"
msgstr "색상표 작업하기 (:class:`QgsColorRamp <qgis.core.QgsColorRamp>` 클래스)"

#: ../../docs/pyqgis_developer_cookbook/vector.rst:1679
msgid "exploring symbol layer and renderer registries"
msgstr "심볼 레이어 및 렌더링 작업자 레지스트리 탐색하기"
