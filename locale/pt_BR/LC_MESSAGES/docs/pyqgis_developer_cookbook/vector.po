# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014, QGIS project
# This file is distributed under the same license as the QGIS Documentation
# Project package.
# 
# Translators:
# Armando Vulcano Junior <vulcano@uol.com.br>, 2015
# Franklin Januário da Silva <frankjanuba@gmail.com>, 2015
# Leônidas Luiz Volcato Descovi Filho <leonidasfilho2000@yahoo.com.br>, 2014
# Mariana Muniz Blank <mariblank_1@hotmail.com>, 2017
# Narcélio de Sá Pereira Filho <narceliosapereira@gmail.com>, 2014
# William Bellinazo Roca <williambr_1331@hotmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: QGIS Documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-06 11:48+0100\n"
"PO-Revision-Date: 2019-12-06 11:03+0000\n"
"Last-Translator: Richard Duivenvoorde <richard@duif.net>\n"
"Language-Team: Portuguese (Brazil) (http://www.transifex.com/qgis/qgis-documentation/language/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:9
msgid "Using Vector Layers"
msgstr "Usando Camadas Vetor"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:14
msgid ""
"This section summarizes various actions that can be done with vector layers."
msgstr "Esta seção lista várias operações que podem ser realizadas com camadas vetoriais."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:16
msgid ""
"Most work here is based on the methods of the :class:`QgsVectorLayer "
"<qgis.core.QgsVectorLayer>` class."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:22
msgid "Retrieving information about attributes"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:24
msgid ""
"You can retrieve information about the fields associated with a vector layer"
" by calling :meth:`fields() <qgis.core.QgsVectorLayer.fields>` on a "
":class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:37
msgid "Iterating over Vector Layer"
msgstr "Interagindo sobre camada vetor"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:39
msgid ""
"Iterating over the features in a vector layer is one of the most common "
"tasks. Below is an example of the simple basic code to perform this task and"
" showing some information about each feature. The ``layer`` variable is "
"assumed to have a :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:88
msgid "Selecting features"
msgstr "Selecionando características"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:90
msgid ""
"In QGIS desktop, features can be selected in different ways: the user can "
"click on a feature, draw a rectangle on the map canvas or use an expression "
"filter. Selected features are normally highlighted in a different color "
"(default is yellow) to draw user's attention on the selection."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:95
msgid ""
"Sometimes it can be useful to programmatically select features or to change "
"the default color."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:98
msgid ""
"To select all the features, the :meth:`selectAll() "
"<qgis.core.QgsVectorLayer.selectAll>` method can be used:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:106
msgid ""
"To select using an expression, use the :meth:`selectByExpression() "
"<qgis.core.QgsVectorLayer.selectByExpression>` method:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:115
msgid ""
"To change the selection color you can use :meth:`setSelectionColor() "
"<qgis.gui.QgsMapCanvas.setSelectionColor>` method of :class:`QgsMapCanvas "
"<qgis.gui.QgsMapCanvas>` as shown in the following example:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:123
msgid ""
"To add features to the selected features list for a given layer, you can "
"call :meth:`select() <qgis.core.QgsVectorLayer.select>` passing to it the "
"list of features IDs:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:138
msgid "To clear the selection:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:145
msgid "Accessing attributes"
msgstr "Acessando atributos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:147
msgid "Attributes can be referred to by their name:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:153
msgid ""
"Alternatively, attributes can be referred to by index. This is a bit faster "
"than using the name. For example, to get the first attribute:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:162
msgid "Iterating over selected features"
msgstr "Iteração sobre os feições selecionadas"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:164
msgid ""
"If you only need selected features, you can use the "
":meth:`selectedFeatures() <qgis.core.QgsVectorLayer.selectedFeatures>` "
"method from the vector layer:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:176
msgid "Iterating over a subset of features"
msgstr "Iterando sobre um subconjunto de feições"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:178
msgid ""
"If you want to iterate over a given subset of features in a layer, such as "
"those within a given area, you have to add a :class:`QgsFeatureRequest "
"<qgis.core.QgsFeatureRequest>` object to the :meth:`getFeatures() "
"<qgis.core.QgsVectorLayer.getFeatures>` call. Here's an example:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:191
msgid ""
"For the sake of speed, the intersection is often done only using feature’s "
"bounding box. There is however a flag ``ExactIntersect`` that makes sure "
"that only intersecting features will be returned:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:199
msgid ""
"With :meth:`setLimit() <qgis.core.QgsFeatureRequest.setLimit>` you can limit"
" the number of requested features. Here's an example:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:209
msgid ""
"If you need an attribute-based filter instead (or in addition) of a spatial "
"one like shown in the examples above, you can build a :class:`QgsExpression "
"<qgis.core.QgsExpression>` object and pass it to the "
":class:`QgsFeatureRequest <qgis.core.QgsFeatureRequest>` constructor. Here's"
" an example:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:222
msgid ""
"See :ref:`expressions` for the details about the syntax supported by "
":class:`QgsExpression <qgis.core.QgsExpression>`."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:224
msgid ""
"The request can be used to define the data retrieved for each feature, so "
"the iterator returns all features, but returns partial data for each of "
"them."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:249
msgid "Modifying Vector Layers"
msgstr "Modificando Camadas Vetoriais"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:251
msgid ""
"Most vector data providers support editing of layer data. Sometimes they "
"support just a subset of possible editing actions. Use the "
":meth:`capabilities() <qgis.core.QgsVectorDataProvider.capabilities>` "
"function to find out what set of functionality is supported."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:263
msgid ""
"For a list of all available capabilities, please refer to the :class:`API "
"Documentation of QgsVectorDataProvider <qgis.core.QgsVectorDataProvider>`."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:267
msgid ""
"To print layer's capabilities textual description in a comma separated list "
"you can use :meth:`capabilitiesString() "
"<qgis.core.QgsVectorDataProvider.capabilitiesString>` as in the following "
"example:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:280
msgid ""
"By using any of the following methods for vector layer editing, the changes "
"are directly committed to the underlying data store (a file, database etc). "
"In case you would like to do only temporary changes, skip to the next "
"section that explains how to do :ref:`modifications with editing buffer "
"<editing-buffer>`."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:288
msgid ""
"If you are working inside QGIS (either from the console or from a plugin), "
"it might be necessary to force a redraw of the map canvas in order to see "
"the changes you've done to the geometry, to the style or to the attributes:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:303
msgid "Add Features"
msgstr "Adicionar feições"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:305
msgid ""
"Create some :class:`QgsFeature <qgis.core.QgsFeature>` instances and pass a "
"list of them to provider's :meth:`addFeatures() "
"<qgis.core.QgsVectorDataProvider.addFeatures>` method. It will return two "
"values: result (true/false) and list of added features (their ID is set by "
"the data store)."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:309
msgid ""
"To set up the attributes of the feature, you can either initialize the "
"feature passing a :class:`QgsFields <qgis.core.QgsFields>` object (you can "
"obtain that from the :meth:`fields() <qgis.core.QgsVectorLayer.fields>` "
"method of the vector layer) or call :meth:`initAttributes() "
"<qgis.core.QgsFeature.initAttributes>` passing the number of fields you want"
" to be added."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:328
msgid "Delete Features"
msgstr "Excluir feições"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:330
msgid "To delete some features, just provide a list of their feature IDs."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:338
msgid "Modify Features"
msgstr "Modificar Feições"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:340
msgid ""
"It is possible to either change feature's geometry or to change some "
"attributes. The following example first changes values of attributes with "
"index 0 and 1, then it changes the feature's geometry."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:357
msgid "**Favor QgsVectorLayerEditUtils class for geometry-only edits**"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:359
msgid ""
"If you only need to change geometries, you might consider using the "
":class:`QgsVectorLayerEditUtils <qgis.core.QgsVectorLayerEditUtils>` which "
"provides some useful methods to edit geometries (translate, insert or move "
"vertex, etc.)."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:366
msgid "Modifying Vector Layers with an Editing Buffer"
msgstr "Modificando Camadas Vetoriais com um Buffer"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:368
msgid ""
"When editing vectors within QGIS application, you have to first start "
"editing mode for a particular layer, then do some modifications and finally "
"commit (or rollback) the changes. All the changes you make are not written "
"until you commit them --- they stay in layer's in-memory editing buffer. It "
"is possible to use this functionality also programmatically --- it is just "
"another method for vector layer editing that complements the direct usage of"
" data providers. Use this option when providing some GUI tools for vector "
"layer editing, since this will allow user to decide whether to "
"commit/rollback and allows the usage of undo/redo. When changes are "
"commited, all changes from the editing buffer are saved to data provider."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:379
msgid ""
"The methods are similar to the ones we have seen in the provider, but they "
"are called on the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` object "
"instead."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:383
msgid ""
"For these methods to work, the layer must be in editing mode. To start the "
"editing mode, use the :meth:`startEditing() "
"<qgis.core.QgsVectorLayer.startEditing>` method. To stop editing, use the "
":meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` or "
":meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` methods. The first "
"one will commit all your changes to the data source, while the second one "
"will discard them and will not modify the data source at all."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:390
msgid ""
"To find out whether a layer is in editing mode, use the :meth:`isEditable() "
"<qgis.core.QgsVectorLayer.isEditable>` method."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:393
msgid ""
"Here you have some examples that demonstrate how to use these editing "
"methods."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:414
msgid ""
"In order to make undo/redo work properly, the above mentioned calls have to "
"be wrapped into undo commands. (If you do not care about undo/redo and want "
"to have the changes stored immediately, then you will have easier work by "
":ref:`editing with data provider <editing>`.)"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:419
msgid "Here is how you can use the undo functionality:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:435
msgid ""
"The :meth:`beginEditCommand() <qgis.core.QgsVectorLayer.beginEditCommand>` "
"method will create an internal \"active\" command and will record subsequent"
" changes in vector layer. With the call to :meth:`endEditCommand() "
"<qgis.core.QgsVectorLayer.endEditCommand>` the command is pushed onto the "
"undo stack and the user will be able to undo/redo it from GUI. In case "
"something went wrong while doing the changes, the "
":meth:`destroyEditCommand() <qgis.core.QgsVectorLayer.destroyEditCommand>` "
"method will remove the command and rollback all changes done while this "
"command was active."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:442
msgid ""
"You can also use the :code:`with edit(layer)`-statement to wrap commit and "
"rollback into a more semantic code block as shown in the example below:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:453
msgid ""
"This will automatically call :meth:`commitChanges() "
"<qgis.core.QgsVectorLayer.commitChanges>` in the end. If any exception "
"occurs, it will :meth:`rollBack() <qgis.core.QgsVectorLayer.rollBack>` all "
"the changes. In case a problem is encountered within :meth:`commitChanges() "
"<qgis.core.QgsVectorLayer.commitChanges>` (when the method returns False) a "
":class:`QgsEditError <qgis.core.QgsEditError>` exception will be raised."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:459
msgid "Adding and Removing Fields"
msgstr "Adicionando e Removendo Campos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:461
msgid ""
"To add fields (attributes), you need to specify a list of field definitions."
" For deletion of fields just provide a list of field indexes."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:476
msgid ""
"After adding or removing fields in the data provider the layer's fields need"
" to be updated because the changes are not automatically propagated."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:483
msgid "**Directly save changes using** ``with`` **based command**"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:485
msgid ""
"Using ``with edit(layer):`` the changes will be commited automatically "
"calling :meth:`commitChanges() <qgis.core.QgsVectorLayer.commitChanges>` at "
"the end. If any exception occurs, it will :meth:`rollBack() "
"<qgis.core.QgsVectorLayer.rollBack>` all the changes. See :ref:`editing-"
"buffer`."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:493
msgid "Using Spatial Index"
msgstr "Utilizando Índices Espaciais"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:495
msgid ""
"Spatial indexes can dramatically improve the performance of your code if you"
" need to do frequent queries to a vector layer. Imagine, for instance, that "
"you are writing an interpolation algorithm, and that for a given location "
"you need to know the 10 closest points from a points layer, in order to use "
"those point for calculating the interpolated value. Without a spatial index,"
" the only way for QGIS to find those 10 points is to compute the distance "
"from each and every point to the specified location and then compare those "
"distances. This can be a very time consuming task, especially if it needs to"
" be repeated for several locations. If a spatial index exists for the layer,"
" the operation is much more effective."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:506
msgid ""
"Think of a layer without a spatial index as a telephone book in which "
"telephone numbers are not ordered or indexed. The only way to find the "
"telephone number of a given person is to read from the beginning until you "
"find it."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:510
msgid ""
"Spatial indexes are not created by default for a QGIS vector layer, but you "
"can create them easily. This is what you have to do:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:513
msgid ""
"create spatial index using the :meth:`QgsSpatialIndex() "
"<qgis.core.QgsVectorLayer.beginEditCommand>` class:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:519
msgid ""
"add features to index --- index takes :class:`QgsFeature "
"<qgis.core.QgsFeature>` object and adds it to the internal data structure. "
"You can create the object manually or use one from a previous call to the "
"provider's :meth:`getFeatures() "
"<qgis.core.QgsVectorDataProvider.getFeatures>` method."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:528
msgid ""
"alternatively, you can load all features of a layer at once using bulk "
"loading"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:534
msgid "once spatial index is filled with some values, you can do some queries"
msgstr "uma vez que o índice espacial é preenchido com alguns valores, você pode fazer algumas consultas"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:548
msgid "Creating Vector Layers"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:550
msgid "There are several ways to generate a vector layer dataset:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:552
msgid ""
"the :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` class: A "
"convenient class for writing vector files to disk, using either a static "
"call to :meth:`writeAsVectorFormat() "
"<qgis.core.QgsVectorFileWriter.writeAsVectorFormat>` which saves the whole "
"vector layer or creating an instance of the class and issue calls to "
":meth:`addFeature() <qgis.core.QgsVectorFileWriter.addFeature>`. This class "
"supports all the vector formats that OGR supports (GeoPackage, Shapefile, "
"GeoJSON, KML and others)."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:560
msgid ""
"the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` class: instantiates a"
" data provider that interprets the supplied path (url) of the data source to"
" connect to and access the data. It can be used to create temporary, memory-"
"based layers (``memory``) and connect to OGR datasets (``ogr``), databases "
"(``postgres``, ``spatialite``, ``mysql``, ``mssql``) and more (``wfs``, "
"``gpx``, ``delimitedtext``...)."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:569
msgid ""
"From an instance of :class:`QgsVectorFileWriter "
"<qgis.core.QgsVectorFileWriter>`"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:590
msgid ""
"The third (mandatory) parameter specifies output text encoding. Only some "
"drivers need this for correct operation - Shapefile is one of them (other "
"drivers will ignore this parameter). Specifying the correct encoding is "
"important if you are using international (non US-ASCII) characters."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:613
msgid ""
"You can also convert fields to make them compatible with different formats "
"by using the  :class:`FieldValueConverter "
"<qgis.core.QgsVectorFileWriter.FieldValueConverter>`. For example, to "
"convert array variable types (e.g. in Postgres) to a text type, you can do "
"the following:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:650
msgid ""
"A destination CRS may also be specified --- if a valid instance of "
":class:`QgsCoordinateReferenceSystem "
"<qgis.core.QgsCoordinateReferenceSystem>` is passed as the fourth parameter,"
" the layer is transformed to that CRS."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:654
msgid ""
"For valid driver names please call the :meth:`supportedFiltersAndFormats "
"<qgis.core.QgsVectorFileWriter.supportedFiltersAndFormats>` method or "
"consult the `supported formats by OGR`_ --- you should pass the value in the"
" \"Code\" column as the driver name."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:659
msgid ""
"Optionally you can set whether to export only selected features, pass "
"further driver-specific options for creation or tell the writer not to "
"create attributes... There are a number of other (optional) parameters; see "
"the :class:`QgsVectorFileWriter <qgis.core.QgsVectorFileWriter>` "
"documentation for details."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:666
msgid "Directly from features"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:705
msgid "From an instance of :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:707
msgid ""
"Among all the data providers supported by the :class:`QgsVectorLayer "
"<qgis.core.QgsVectorLayer>` class, let's focus on the memory-based layers. "
"Memory provider is intended to be used mainly by plugin or 3rd party app "
"developers. It does not store data on disk, allowing developers to use it as"
" a fast backend for some temporary layers."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:713
msgid "The provider supports string, int and double fields."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:715
msgid ""
"The memory provider also supports spatial indexing, which is enabled by "
"calling the provider's :meth:`createSpatialIndex() "
"<qgis.core.QgsVectorDataProvider.createSpatialIndex>` function. Once the "
"spatial index is created you will be able to iterate over features within "
"smaller regions faster (since it's not necessary to traverse all the "
"features, only those in specified rectangle)."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:722
msgid ""
"A memory provider is created by passing ``\"memory\"`` as the provider "
"string to the :class:`QgsVectorLayer <qgis.core.QgsVectorLayer>` "
"constructor."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:725
msgid ""
"The constructor also takes a URI defining the geometry type of the layer, "
"one of: ``\"Point\"``, ``\"LineString\"``, ``\"Polygon\"``, "
"``\"MultiPoint\"``, ``\"MultiLineString\"``, ``\"MultiPolygon\"`` or "
"``\"None\"``."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:729
msgid ""
"The URI can also specify the coordinate reference system, fields, and "
"indexing of the memory provider in the URI. The syntax is:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:735
msgid "crs=definition"
msgstr "crs=definição"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:733
msgid ""
"Specifies the coordinate reference system, where definition may be any of "
"the forms accepted by :meth:`QgsCoordinateReferenceSystem.createFromString "
"<qgis.core.QgsCoordinateReferenceSystem.createFromString>`"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:738
msgid "index=yes"
msgstr "index=yes"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:738
msgid "Specifies that the provider will use a spatial index"
msgstr "Especifica que o provedor irá usar o index espacial"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:743
msgid "field=name:type(length,precision)"
msgstr "field=name:type(tamanho,precisão)"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:741
msgid ""
"Specifies an attribute of the layer.  The attribute has a name, and "
"optionally a type (integer, double, or string), length, and precision. There"
" may be multiple field definitions."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:745
msgid "The following example of a URI incorporates all these options"
msgstr "O exemplo seguinte de URL incorpora todas estas opções "

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:751
msgid ""
"The following example code illustrates creating and populating a memory "
"provider"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:777
msgid "Finally, let's check whether everything went well"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:795
msgid "Appearance (Symbology) of Vector Layers"
msgstr "Aparencia (Simbologia) de Camadas de Vetor"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:797
msgid ""
"When a vector layer is being rendered, the appearance of the data is given "
"by **renderer** and **symbols** associated with the layer.  Symbols are "
"classes which take care of drawing of visual representation of features, "
"while renderers determine what symbol will be used for a particular feature."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:802
msgid "The renderer for a given layer can be obtained as shown below:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:808
msgid "And with that reference, let us explore it a bit"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:814
msgid ""
"There are several known renderer types available in the QGIS core library:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:817
msgid "Type"
msgstr "Tipo"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:817
msgid "Class"
msgstr "Classes"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:817
msgid "Description"
msgstr "Descrição"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:819
msgid "singleSymbol"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:819
msgid ":class:`QgsSingleSymbolRenderer <qgis.core.QgsSingleSymbolRenderer>`"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:819
msgid "Renders all features with the same symbol"
msgstr "Renderiza todas as características com o mesmo símbolo"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:820
msgid "categorizedSymbol"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:820
msgid ""
":class:`QgsCategorizedSymbolRenderer "
"<qgis.core.QgsCategorizedSymbolRenderer>`"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:820
msgid "Renders features using a different symbol for each category"
msgstr "Renderiza características usando um símbolo diferente para cada categoria"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:821
msgid "graduatedSymbol"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:821
msgid ""
":class:`QgsGraduatedSymbolRenderer  <qgis.core.QgsGraduatedSymbolRenderer>`"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:821
msgid "Renders features using a different symbol for each range of values"
msgstr "Renderiza caracter´sticas usando diferents símbolos para cada limite de valores"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:826
msgid ""
"There might be also some custom renderer types, so never make an assumption "
"there are just these types. You can query the application's "
":class:`QgsRendererRegistry <qgis.core.QgsRendererRegistry>` to find out "
"currently available renderers:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:845
msgid ""
"It is possible to obtain a dump of a renderer contents in text form --- can "
"be useful for debugging"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:855
msgid "Single Symbol Renderer"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:857
msgid ""
"You can get the symbol used for rendering by calling :meth:`symbol() "
"<qgis.core.QgsSingleSymbolRenderer.symbol>` method and change it with "
":meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` method "
"(note for C++ devs: the renderer takes ownership of the symbol.)"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:861
msgid ""
"You can change the symbol used by a particular vector layer by calling "
":meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>` passing an"
" instance of the appropriate symbol instance. Symbols for *point*, *line* "
"and *polygon* layers can be created by calling the :meth:`createSimple() "
"<qgis.core.QgsMarkerSymbol.createSimple>` function of the corresponding "
"classes :class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>`, "
":class:`QgsLineSymbol <qgis.core.QgsLineSymbol>` and :class:`QgsFillSymbol "
"<qgis.core.QgsFillSymbol>`."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:868
msgid ""
"The dictionary passed to :meth:`createSimple() "
"<qgis.core.QgsMarkerSymbol.createSimple>` sets the style properties of the "
"symbol."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:871
msgid ""
"For example you can replace the symbol used by a particular **point** layer "
"by calling :meth:`setSymbol() <qgis.core.QgsSingleSymbolRenderer.setSymbol>`"
" passing an instance of a :class:`QgsMarkerSymbol "
"<qgis.core.QgsMarkerSymbol>`, as in the following code example:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:882
msgid ""
"``name`` indicates the shape of the marker, and can be any of the following:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:884
msgid "``circle``"
msgstr "``circulo``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:885
msgid "``square``"
msgstr "``quadrado``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:886
msgid "``cross``"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:887
msgid "``rectangle``"
msgstr "`retângulo``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:888
msgid "``diamond``"
msgstr "``diamante``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:889
msgid "``pentagon``"
msgstr "``pentágono``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:890
msgid "``triangle``"
msgstr "``triângulo``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:891
msgid "``equilateral_triangle``"
msgstr "``triângulo_equilateral``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:892
msgid "``star``"
msgstr "``estrela``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:893
msgid "``regular_star``"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:894
msgid "``arrow``"
msgstr "``flecha``"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:895
msgid "``filled_arrowhead``"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:896
msgid "``x``"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:899
msgid ""
"To get the full list of properties for the first symbol layer of a symbol "
"instance you can follow the example code:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:925
msgid "This can be useful if you want to alter some properties:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:944
msgid "Categorized Symbol Renderer"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:946
msgid ""
"When using a categorized renderer, you can query and set the attribute that "
"is used for classification: use the :meth:`classAttribute() "
"<qgis.core.QgsCategorizedSymbolRenderer.classAttribute>` and "
":meth:`setClassAttribute() "
"<qgis.core.QgsCategorizedSymbolRenderer.setClassAttribute>` methods."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:949
msgid "To get a list of categories"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:956
msgid ""
"Where :meth:`value() <qgis.core.QgsRendererCategory.value>` is the value "
"used for discrimination between categories, :meth:`label() "
"<qgis.core.QgsRendererCategory.label>` is a text used for category "
"description and :meth:`symbol() <qgis.core.QgsRendererCategory.symbol>` "
"method returns the assigned symbol."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:960
msgid ""
"The renderer usually stores also original symbol and color ramp which were "
"used for the classification: :meth:`sourceColorRamp() "
"<qgis.core.QgsCategorizedSymbolRenderer.sourceColorRamp>` and "
":meth:`sourceSymbol() <qgis.core.QgsCategorizedSymbolRenderer.sourceSymbol>`"
" methods."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:966
msgid "Graduated Symbol Renderer"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:968
msgid ""
"This renderer is very similar to the categorized symbol renderer described "
"above, but instead of one attribute value per class it works with ranges of "
"values and thus can be used only with numerical attributes."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:972
msgid "To find out more about ranges used in the renderer"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:984
msgid ""
"you can again use the :meth:`classAttribute "
"<qgis.core.QgsGraduatedSymbolRenderer.classAttribute>` (to find the "
"classification attribute name), :meth:`sourceSymbol "
"<qgis.core.QgsGraduatedSymbolRenderer.sourceSymbol>` and "
":meth:`sourceColorRamp "
"<qgis.core.QgsGraduatedSymbolRenderer.sourceColorRamp>` methods. "
"Additionally there is the :meth:`mode "
"<qgis.core.QgsGraduatedSymbolRenderer.mode>` method which determines how the"
" ranges were created: using equal intervals, quantiles or some other method."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:993
msgid ""
"If you wish to create your own graduated symbol renderer you can do so as "
"illustrated in the example snippet below (which creates a simple two class "
"arrangement)"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1037
msgid "Working with Symbols"
msgstr "Trabalhando com Símbolos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1039
msgid ""
"For representation of symbols, there is :class:`QgsSymbol "
"<qgis.core.QgsSymbol>` base class with three derived classes:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1042
msgid ""
":class:`QgsMarkerSymbol <qgis.core.QgsMarkerSymbol>` --- for point features"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1043
msgid ":class:`QgsLineSymbol <qgis.core.QgsLineSymbol>` --- for line features"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1044
msgid ""
":class:`QgsFillSymbol <qgis.core.QgsFillSymbol>` --- for polygon features"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1046
msgid ""
"**Every symbol consists of one or more symbol layers** (classes derived from"
" :class:`QgsSymbolLayer <qgis.core.QgsSymbolLayer>`). The symbol layers do "
"the actual rendering, the symbol class itself serves only as a container for"
" the symbol layers."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1050
msgid ""
"Having an instance of a symbol (e.g. from a renderer), it is possible to "
"explore it: the :meth:`type <qgis.core.QgsSymbol.type>` method says whether "
"it is a marker, line or fill symbol. There is a :meth:`dump "
"<qgis.core.QgsSymbol.dump>` method which returns a brief description of the "
"symbol. To get a list of symbol layers:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1062
msgid ""
"To find out symbol's color use :meth:`color <qgis.core.QgsSymbol.color>` "
"method and :meth:`setColor <qgis.core.QgsSymbol.setColor>` to change its "
"color. With marker symbols additionally you can query for the symbol size "
"and rotation with the :meth:`size <qgis.core.QgsMarkerSymbol.size>` and "
":meth:`angle <qgis.core.QgsMarkerSymbol.angle>` methods. For line symbols "
"the :meth:`width <qgis.core.QgsLineSymbol.width>` method returns the line "
"width."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1067
msgid "Size and width are in millimeters by default, angles are in degrees."
msgstr "Por padrão, tamanho e largura são em milimetros e ângulos em graus."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1072
msgid "Working with Symbol Layers"
msgstr "Trabalhando com Camadas de Símbolos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1074
msgid ""
"As said before, symbol layers (subclasses of :class:`QgsSymbolLayer "
"<qgis.core.QgsSymbolLayer>`) determine the appearance of the features.  "
"There are several basic symbol layer classes for general use. It is possible"
" to implement new symbol layer types and thus arbitrarily customize how "
"features will be rendered. The :meth:`layerType() "
"<qgis.core.QgsSymbolLayer.layerType>` method uniquely identifies the symbol "
"layer class --- the basic and default ones are ``SimpleMarker``, "
"``SimpleLine`` and ``SimpleFill`` symbol layers types."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1081
msgid ""
"You can get a complete list of the types of symbol layers you can create for"
" a given symbol layer class with the following code:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1092
msgid "Output:"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1104
msgid ""
"The :class:`QgsSymbolLayerRegistry <qgis.core.QgsSymbolLayerRegistry>` class"
" manages a database of all available symbol layer types."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1107
msgid ""
"To access symbol layer data, use its :meth:`properties() "
"<qgis.core.QgsSymbolLayer.properties>` method that returns a key-value "
"dictionary of properties which determine the appearance. Each symbol layer "
"type has a specific set of properties that it uses. Additionally, there are "
"the generic methods :meth:`color <qgis.core.QgsSymbol.color>`, :meth:`size "
"<qgis.core.QgsMarkerSymbol.size>`, :meth:`angle "
"<qgis.core.QgsMarkerSymbol.angle>` and :meth:`width "
"<qgis.core.QgsLineSymbol.width>`, with their setter counterparts. Of course "
"size and angle are available only for marker symbol layers and width for "
"line symbol layers."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1119
msgid "Creating Custom Symbol Layer Types"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1121
msgid ""
"Imagine you would like to customize the way how the data gets rendered. You "
"can create your own symbol layer class that will draw the features exactly "
"as you wish. Here is an example of a marker that draws red circles with "
"specified radius"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1161
msgid ""
"The :meth:`layerType <qgis.core.QgsSymbolLayer.layerType>` method determines"
" the name of the symbol layer; it has to be unique among all symbol layers. "
"The :meth:`properties <qgis.core.QgsSymbolLayer.properties>` method is used "
"for persistence of attributes. The :meth:`clone "
"<qgis.core.QgsSymbolLayer.clone>` method must return a copy of the symbol "
"layer with all attributes being exactly the same. Finally there are "
"rendering methods: :meth:`startRender "
"<qgis.core.QgsSymbolLayer.startRender>` is called before rendering the first"
" feature, :meth:`stopRender <qgis.core.QgsSymbolLayer.stopRender>` when the "
"rendering is done, and :meth:`renderPoint "
"<qgis.core.QgsMarkerSymbolLayer.renderPoint>` is called to do the rendering."
" The coordinates of the point(s) are already transformed to the output "
"coordinates."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1173
msgid ""
"For polylines and polygons the only difference would be in the rendering "
"method: you would use :meth:`renderPolyline "
"<qgis.core.QgsLineSymbolLayer.renderPolyline>` which receives a list of "
"lines, while :meth:`renderPolygon "
"<qgis.core.QgsFillSymbolLayer.renderPolygon>` receives a list of points on "
"the outer ring as the first parameter and a list of inner rings (or None) as"
" a second parameter."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1181
msgid ""
"Usually it is convenient to add a GUI for setting attributes of the symbol "
"layer type to allow users to customize the appearance: in case of our "
"example above we can let user set circle radius. The following code "
"implements such widget"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1219
msgid ""
"This widget can be embedded into the symbol properties dialog. When the "
"symbol layer type is selected in symbol properties dialog, it creates an "
"instance of the symbol layer and an instance of the symbol layer widget. "
"Then it calls the :meth:`setSymbolLayer "
"<qgis.gui.QgsSymbolLayerWidget.setSymbolLayer>` method to assign the symbol "
"layer to the widget. In that method the widget should update the UI to "
"reflect the attributes of the symbol layer. The :meth:`symbolLayer "
"<qgis.gui.QgsSymbolLayerWidget.symbolLayer>` method is used to retrieve the "
"symbol layer again by the properties dialog to use it for the symbol."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1229
msgid ""
"On every change of attributes, the widget should emit the :any:`changed() "
"<qgis.gui.QgsSymbolLayerWidget.changed>` signal to let the properties dialog"
" update the symbol preview."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1233
msgid ""
"Now we are missing only the final glue: to make QGIS aware of these new "
"classes. This is done by adding the symbol layer to registry. It is possible"
" to use the symbol layer also without adding it to the registry, but some "
"functionality will not work: e.g. loading of project files with the custom "
"symbol layers or inability to edit the layer's attributes in GUI."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1239
msgid "We will have to create metadata for the symbol layer"
msgstr "Você terá que criar metadados para a camada de símbolos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1260
msgid ""
"You should pass layer type (the same as returned by the layer) and symbol "
"type (marker/line/fill) to the constructor of the parent class. The "
":meth:`createSymbolLayer() "
"<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayer>` method takes "
"care of creating an instance of symbol layer with attributes specified in "
"the `props` dictionary. And there is the :meth:`createSymbolLayerWidget() "
"<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayerWidget>` method "
"which returns the settings widget for this symbol layer type."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1268
msgid ""
"The last step is to add this symbol layer to the registry --- and we are "
"done."
msgstr "O último passo para adicionar este símbolo de camada para o registro --- e estamos prontos."

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1274
msgid "Creating Custom Renderers"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1276
msgid ""
"It might be useful to create a new renderer implementation if you would like"
" to customize the rules how to select symbols for rendering of features. "
"Some use cases where you would want to do it: symbol is determined from a "
"combination of fields, size of symbols changes depending on current scale "
"etc."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1281
msgid ""
"The following code shows a simple custom renderer that creates two marker "
"symbols and chooses randomly one of them for every feature"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1337
msgid ""
"The constructor of the parent :class:`QgsFeatureRenderer "
"<qgis.core.QgsFeatureRenderer>` class needs a renderer name (which has to be"
" unique among renderers). The :meth:`symbolForFeature "
"<qgis.core.QgsFeatureRenderer.symbolForFeature>` method is the one that "
"decides what symbol will be used for a particular feature. "
":meth:`startRender <qgis.core.QgsFeatureRenderer.startRender>` and "
":meth:`stopRender <qgis.core.QgsFeatureRenderer.stopRender>` take care of "
"initialization/finalization of symbol rendering. The :meth:`usedAttributes "
"<qgis.core.QgsFeatureRenderer.usedAttributes>` method can return a list of "
"field names that the renderer expects to be present. Finally, the "
":meth:`clone <qgis.core.QgsFeatureRenderer.clone>` method should return a "
"copy of the renderer."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1348
msgid ""
"Like with symbol layers, it is possible to attach a GUI for configuration of"
" the renderer. It has to be derived from :class:`QgsRendererWidget "
"<qgis.gui.QgsRendererWidget>`. The following sample code creates a button "
"that allows the user to set the first symbol"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1382
msgid ""
"The constructor receives instances of the active layer "
"(:class:`QgsVectorLayer <qgis.core.QgsVectorLayer>`), the global style "
"(:class:`QgsStyle <qgis.core.QgsStyle>`) and the current renderer. If there "
"is no renderer or the renderer has different type, it will be replaced with "
"our new renderer, otherwise we will use the current renderer (which has "
"already the type we need). The widget contents should be updated to show "
"current state of the renderer. When the renderer dialog is accepted, the "
"widget's :meth:`renderer <qgis.gui.QgsRendererWidget.renderer>` method is "
"called to get the current renderer --- it will be assigned to the layer."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1392
msgid ""
"The last missing bit is the renderer metadata and registration in registry, "
"otherwise loading of layers with the renderer will not work and user will "
"not be able to select it from the list of renderers. Let us finish our "
"RandomRenderer example"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1412
msgid ""
"Similarly as with symbol layers, abstract metadata constructor awaits "
"renderer name, name visible for users and optionally name of renderer's "
"icon. The :meth:`createRenderer "
"<qgis.core.QgsRendererAbstractMetadata.createRenderer>` method passes a "
":class:`QDomElement` instance that can be used to restore the renderer's "
"state from the DOM tree. The :meth:`createRendererWidget "
"<qgis.core.QgsRendererAbstractMetadata.createRendererWidget>` method creates"
" the configuration widget. It does not have to be present or can return "
"``None`` if the renderer does not come with GUI."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1421
msgid ""
"To associate an icon with the renderer you can assign it in the "
":class:`QgsRendererAbstractMetadata <qgis.core.QgsRendererAbstractMetadata>`"
" constructor as a third (optional) argument --- the base class constructor "
"in the RandomRendererMetadata :func:`__init__` function becomes"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1434
msgid ""
"The icon can also be associated at any later time using the :meth:`setIcon "
"<qgis.core.QgsRendererAbstractMetadata.setIcon>` method of the metadata "
"class. The icon can be loaded from a file (as shown above) or can be loaded "
"from a `Qt resource <https://doc.qt.io/qt-5/resources.html>`_ (PyQt5 "
"includes .qrc compiler for Python)."
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1442
msgid "Further Topics"
msgstr "Outros Tópicos"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1445
msgid "**TODO:**"
msgstr "**TODO:**"

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1447
msgid "creating/modifying symbols"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1448
msgid "working with style (:class:`QgsStyle <qgis.core.QgsStyle>`)"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1449
msgid ""
"working with color ramps (:class:`QgsColorRamp <qgis.core.QgsColorRamp>`)"
msgstr ""

#: ../../source/docs/pyqgis_developer_cookbook/vector.rst:1450
msgid "exploring symbol layer and renderer registries"
msgstr ""

#~ msgid ""
#~ "You can retrieve information about the fields associated with a vector layer"
#~ " by calling :func:`pendingFields` on a :class:`QgsVectorLayer` instance::"
#~ msgstr ""

#~ msgid ""
#~ "Starting from QGIS 2.12 there is also a :func:`fields()` in "
#~ ":class:`QgsVectorLayer` which is an alias to :func:`pendingFields`."
#~ msgstr ""

#~ msgid ""
#~ "In QGIS desktop, features can be selected in different ways, the user can "
#~ "click on a feature, draw a rectangle on the map canvas or use an expression "
#~ "filter. Selected features are normally highlighted in a different color "
#~ "(default is yellow) to draw user's attention on the selection. Sometimes can"
#~ " be useful to programmatically select features or to change the default "
#~ "color."
#~ msgstr ""

#~ msgid ""
#~ "To change the selection color you can use :func:`setSelectionColor()` method"
#~ " of :class:`QgsMapCanvas` as shown in the following example::"
#~ msgstr ""

#~ msgid ""
#~ "To add add features to the selected features list for a given layer, you can"
#~ " call :func:`setSelectedFeatures()` passing to it the list of features IDs::"
#~ msgstr ""

#~ msgid "To clear the selection, just pass an empty list::"
#~ msgstr ""

#~ msgid ""
#~ "Iterating over the features in a vector layer is one of the most common "
#~ "tasks. Below is an example of the simple basic code to perform this task and"
#~ " showing some information about each feature. the ``layer`` variable is "
#~ "assumed to have a :class:`QgsVectorLayer` object"
#~ msgstr ""

#~ msgid "Attributes can be referred to by their name."
#~ msgstr ""

#~ msgid ""
#~ "Alternatively, attributes can be referred to by index. This is will be a bit"
#~ " faster than using the name. For example, to get the first attribute:"
#~ msgstr ""

#~ msgid ""
#~ "if you only need selected features, you can use the :func:`selectedFeatures`"
#~ " method from vector layer:"
#~ msgstr ""

#~ msgid "Another option is the Processing :func:`features` method:"
#~ msgstr ""

#~ msgid ""
#~ "By default, this will iterate over all the features in the layer, in case "
#~ "there is no selection, or over the selected features otherwise. Note that "
#~ "this behavior can be changed in the Processing options to ignore selections."
#~ msgstr ""

#~ msgid ""
#~ "If you want to iterate over a given subset of features in a layer, such as "
#~ "those within a given area, you have to add a :obj:`QgsFeatureRequest` object"
#~ " to the :func:`getFeatures()` call. Here's an example"
#~ msgstr ""

#~ msgid ""
#~ "With :func:`setLimit()` you can limit the number of requested features. "
#~ "Here's an example"
#~ msgstr ""

#~ msgid ""
#~ "If you need an attribute-based filter instead (or in addition) of a spatial "
#~ "one like shown in the examples above, you can build an :obj:`QgsExpression` "
#~ "object and pass it to the :obj:`QgsFeatureRequest` constructor. Here's an "
#~ "example"
#~ msgstr ""

#~ msgid ""
#~ "See :ref:`expressions` for the details about the syntax supported by "
#~ ":class:`QgsExpression`."
#~ msgstr ""

#~ msgid "**Speed features request**"
#~ msgstr ""

#~ msgid ""
#~ "If you only need a subset of the attributes or you don't need the geometry "
#~ "information, you can significantly increase the **speed** of the features "
#~ "request by using ``QgsFeatureRequest.NoGeometry`` flag or specifying a "
#~ "subset of attributes (possibly empty) like shown in the example above."
#~ msgstr ""

#~ msgid ""
#~ "Most vector data providers support editing of layer data. Sometimes they "
#~ "support just a subset of possible editing actions. Use the "
#~ ":func:`capabilities` function to find out what set of functionality is "
#~ "supported"
#~ msgstr ""

#~ msgid ""
#~ "For a list of all available capabilities, please refer to the `API "
#~ "Documentation of QgsVectorDataProvider "
#~ "<http://qgis.org/api/classQgsVectorDataProvider.html>`_"
#~ msgstr ""

#~ msgid ""
#~ "To print layer's capabilities textual description in a comma separated list "
#~ "you can use :func:`capabilitiesString` as in the following example:"
#~ msgstr ""

#~ msgid ""
#~ "Create some :class:`QgsFeature` instances and pass a list of them to "
#~ "provider's :func:`addFeatures` method. It will return two values: result "
#~ "(true/false) and list of added features (their ID is set by the data store)."
#~ msgstr ""

#~ msgid ""
#~ "To set up the attributes you can either initialize the feature passing a "
#~ ":class:`QgsFields` instance or call :func:`initAttributes` passing the "
#~ "number of fields you want to be added."
#~ msgstr ""

#~ msgid "To delete some features, just provide a list of their feature IDs"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to either change feature's geometry or to change some "
#~ "attributes. The following example first changes values of attributes with "
#~ "index 0 and 1, then it changes the feature's geometry"
#~ msgstr ""

#~ msgid ""
#~ "If you only need to change geometries, you might consider using the "
#~ ":class:`QgsVectorLayerEditUtils` which provides some of useful methods to "
#~ "edit geometries (translate, insert or move vertex etc.)."
#~ msgstr ""

#~ msgid ""
#~ "Using ``with edit(layer):`` the changes will be commited automatically "
#~ "calling :func:`commitChanges()` at the end. If any exception occurs, it will"
#~ " :func:`rollBack()` all the changes. See :ref:`editing-buffer`."
#~ msgstr ""

#~ msgid ""
#~ "When editing vectors within QGIS application, you have to first start "
#~ "editing mode for a particular layer, then do some modifications and finally "
#~ "commit (or rollback) the changes. All the changes you do are not written "
#~ "until you commit them --- they stay in layer's in-memory editing buffer. It "
#~ "is possible to use this functionality also programmatically --- it is just "
#~ "another method for vector layer editing that complements the direct usage of"
#~ " data providers. Use this option when providing some GUI tools for vector "
#~ "layer editing, since this will allow user to decide whether to "
#~ "commit/rollback and allows the usage of undo/redo. When committing changes, "
#~ "all changes from the editing buffer are saved to data provider."
#~ msgstr ""

#~ msgid ""
#~ "To find out whether a layer is in editing mode, use :func:`isEditable` --- "
#~ "the editing functions work only when the editing mode is turned on. Usage of"
#~ " editing functions"
#~ msgstr ""

#~ msgid ""
#~ "In order to make undo/redo work properly, the above mentioned calls have to "
#~ "be wrapped into undo commands. (If you do not care about undo/redo and want "
#~ "to have the changes stored immediately, then you will have easier work by "
#~ ":ref:`editing with data provider <editing>`.) How to use the undo "
#~ "functionality"
#~ msgstr ""

#~ msgid ""
#~ "The :func:`beginEditCommand` will create an internal \"active\" command and "
#~ "will record subsequent changes in vector layer. With the call to "
#~ ":func:`endEditCommand` the command is pushed onto the undo stack and the "
#~ "user will be able to undo/redo it from GUI. In case something went wrong "
#~ "while doing the changes, the :func:`destroyEditCommand` method will remove "
#~ "the command and rollback all changes done while this command was active."
#~ msgstr ""

#~ msgid ""
#~ "To start editing mode, there is :func:`startEditing()` method, to stop "
#~ "editing there are :func:`commitChanges()` and :func:`rollBack()` --- however"
#~ " normally you should not need these methods and leave this functionality to "
#~ "be triggered by the user."
#~ msgstr ""

#~ msgid ""
#~ "This will automatically call :func:`commitChanges()` in the end. If any "
#~ "exception occurs, it will :func:`rollBack()` all the changes. In case a "
#~ "problem is encountered within :func:`commitChanges()` (when the method "
#~ "returns False) a :class:`QgsEditError` exception will be raised."
#~ msgstr ""

#~ msgid "create spatial index --- the following code creates an empty index"
#~ msgstr ""

#~ msgid ""
#~ "add features to index --- index takes :class:`QgsFeature` object and adds it"
#~ " to the internal data structure. You can create the object manually or use "
#~ "one from previous call to provider's :func:`nextFeature()`"
#~ msgstr ""

#~ msgid "Writing Vector Layers"
#~ msgstr ""

#~ msgid ""
#~ "You can write vector layer files using :class:`QgsVectorFileWriter` class. "
#~ "It supports any other kind of vector file that OGR supports (shapefiles, "
#~ "GeoJSON, KML and others)."
#~ msgstr ""

#~ msgid "There are two possibilities how to export a vector layer:"
#~ msgstr ""

#~ msgid "from an instance of :class:`QgsVectorLayer`"
#~ msgstr ""

#~ msgid ""
#~ "The third parameter specifies output text encoding. Only some drivers need "
#~ "this for correct operation - shapefiles are one of those --- however in case"
#~ " you are not using international characters you do not have to care much "
#~ "about the encoding. The fourth parameter that we left as ``None`` may "
#~ "specify destination CRS --- if a valid instance of "
#~ ":class:`QgsCoordinateReferenceSystem` is passed, the layer is transformed to"
#~ " that CRS."
#~ msgstr ""

#~ msgid "directly from features"
#~ msgstr ""

#~ msgid "Memory Provider"
#~ msgstr ""

#~ msgid ""
#~ "Memory provider is intended to be used mainly by plugin or 3rd party app "
#~ "developers. It does not store data on disk, allowing developers to use it as"
#~ " a fast backend for some temporary layers."
#~ msgstr ""

#~ msgid ""
#~ "The memory provider also supports spatial indexing, which is enabled by "
#~ "calling the provider's :func:`createSpatialIndex` function. Once the spatial"
#~ " index is created you will be able to iterate over features within smaller "
#~ "regions faster (since it's not necessary to traverse all the features, only "
#~ "those in specified rectangle)."
#~ msgstr ""

#~ msgid ""
#~ "A memory provider is created by passing ``\"memory\"`` as the provider "
#~ "string to the :class:`QgsVectorLayer` constructor."
#~ msgstr ""

#~ msgid ""
#~ "Specifies the coordinate reference system, where definition may be any of "
#~ "the forms accepted by :func:`QgsCoordinateReferenceSystem.createFromString`"
#~ msgstr ""

#~ msgid "The renderer for a given layer can obtained as shown below:"
#~ msgstr ""

#~ msgid "There are several known renderer types available in QGIS core library:"
#~ msgstr ""

#~ msgid ":class:`QgsSingleSymbolRendererV2`"
#~ msgstr ""

#~ msgid ":class:`QgsCategorizedSymbolRendererV2`"
#~ msgstr ""

#~ msgid ":class:`QgsGraduatedSymbolRendererV2`"
#~ msgstr ""

#~ msgid ""
#~ "There might be also some custom renderer types, so never make an assumption "
#~ "there are just these types. You can query :class:`QgsRendererV2Registry` "
#~ "singleton to find out currently available renderers:"
#~ msgstr ""

#~ msgid ""
#~ "You can get the symbol used for rendering by calling :func:`symbol` method "
#~ "and change it with :func:`setSymbol` method (note for C++ devs: the renderer"
#~ " takes ownership of the symbol.)"
#~ msgstr ""

#~ msgid ""
#~ "You can change the symbol used by a particular vector layer by calling "
#~ ":func:`setSymbol()` passing an instance of the appropriate symbol instance. "
#~ "Symbols for *point*, *line* and *polygon* layers can be created by calling "
#~ "the :func:`createSimple` function of the corresponding classes "
#~ ":class:`QgsMarkerSymbolV2`, :class:`QgsLineSymbolV2` and "
#~ ":class:`QgsFillSymbolV2`."
#~ msgstr ""

#~ msgid ""
#~ "The dictionary passed to :func:`createSimple` sets the style properties of "
#~ "the symbol."
#~ msgstr ""

#~ msgid ""
#~ "For example you can replace the symbol used by a particular **point** layer "
#~ "by calling :func:`setSymbol()` passing an instance of a "
#~ ":class:`QgsMarkerSymbolV2` as in the following code example:"
#~ msgstr ""

#~ msgid ""
#~ "To get the full list of properties for the first symbol layer of a simbol "
#~ "instance you can follow the example code:"
#~ msgstr ""

#~ msgid ""
#~ "You can query and set attribute name which is used for classification: use "
#~ ":func:`classAttribute` and :func:`setClassAttribute` methods."
#~ msgstr ""

#~ msgid ""
#~ "Where :func:`value` is the value used for discrimination between categories,"
#~ " :func:`label` is a text used for category description and :func:`symbol` "
#~ "method returns assigned symbol."
#~ msgstr ""

#~ msgid ""
#~ "The renderer usually stores also original symbol and color ramp which were "
#~ "used for the classification: :func:`sourceColorRamp` and "
#~ ":func:`sourceSymbol` methods."
#~ msgstr ""

#~ msgid ""
#~ "For representation of symbols, there is :class:`QgsSymbolV2` base class with"
#~ " three derived classes:"
#~ msgstr ""

#~ msgid ":class:`QgsMarkerSymbolV2` --- for point features"
#~ msgstr ""

#~ msgid ":class:`QgsLineSymbolV2` --- for line features"
#~ msgstr ""

#~ msgid ":class:`QgsFillSymbolV2` --- for polygon features"
#~ msgstr ""

#~ msgid ""
#~ "**Every symbol consists of one or more symbol layers** (classes derived from"
#~ " :class:`QgsSymbolLayerV2`). The symbol layers do the actual rendering, the "
#~ "symbol class itself serves only as a container for the symbol layers."
#~ msgstr ""

#~ msgid ""
#~ "Having an instance of a symbol (e.g. from a renderer), it is possible to "
#~ "explore it: :func:`type` method says whether it is a marker, line or fill "
#~ "symbol. There is a :func:`dump` method which returns a brief description of "
#~ "the symbol. To get a list of symbol layers"
#~ msgstr ""

#~ msgid ""
#~ "To find out symbol's color use :func:`color` method and :func:`setColor` to "
#~ "change its color. With marker symbols additionally you can query for the "
#~ "symbol size and rotation with :func:`size` and :func:`angle` methods, for "
#~ "line symbols there is :func:`width` method returning line width."
#~ msgstr ""

#~ msgid ""
#~ "As said before, symbol layers (subclasses of :class:`QgsSymbolLayerV2`) "
#~ "determine the appearance of the features.  There are several basic symbol "
#~ "layer classes for general use. It is possible to implement new symbol layer "
#~ "types and thus arbitrarily customize how features will be rendered. The "
#~ ":func:`layerType` method uniquely identifies the symbol layer class --- the "
#~ "basic and default ones are SimpleMarker, SimpleLine and SimpleFill symbol "
#~ "layers types."
#~ msgstr ""

#~ msgid ""
#~ "You can get a complete list of the types of symbol layers you can create for"
#~ " a given symbol layer class like this"
#~ msgstr ""

#~ msgid "Output"
#~ msgstr ""

#~ msgid ""
#~ ":class:`QgsSymbolLayerV2Registry` class manages a database of all available "
#~ "symbol layer types."
#~ msgstr ""

#~ msgid ""
#~ "To access symbol layer data, use its :func:`properties` method that returns "
#~ "a key-value dictionary of properties which determine the appearance. Each "
#~ "symbol layer type has a specific set of properties that it uses. "
#~ "Additionally, there are generic methods :func:`color`, :func:`size`, "
#~ ":func:`angle`, :func:`width` with their setter counterparts. Of course size "
#~ "and angle is available only for marker symbol layers and width for line "
#~ "symbol layers."
#~ msgstr ""

#~ msgid ""
#~ "The :func:`layerType` method determines the name of the symbol layer, it has"
#~ " to be unique among all symbol layers. Properties are used for persistence "
#~ "of attributes. :func:`clone` method must return a copy of the symbol layer "
#~ "with all attributes being exactly the same. Finally there are rendering "
#~ "methods: :func:`startRender` is called before rendering first feature, "
#~ ":func:`stopRender` when rendering is done. And :func:`renderPoint` method "
#~ "which does the rendering. The coordinates of the point(s) are already "
#~ "transformed to the output coordinates."
#~ msgstr ""

#~ msgid ""
#~ "For polylines and polygons the only difference would be in the rendering "
#~ "method: you would use :func:`renderPolyline` which receives a list of lines,"
#~ " resp. :func:`renderPolygon` which receives list of points on outer ring as "
#~ "a first parameter and a list of inner rings (or None) as a second parameter."
#~ msgstr ""

#~ msgid ""
#~ "You should pass layer type (the same as returned by the layer) and symbol "
#~ "type (marker/line/fill) to the constructor of parent class. "
#~ ":func:`createSymbolLayer` takes care of creating an instance of symbol layer"
#~ " with attributes specified in the `props` dictionary. (Beware, the keys are "
#~ "QString instances, not \"str\" objects). And there is "
#~ ":func:`createSymbolLayerWidget` method which returns settings widget for "
#~ "this symbol layer type."
#~ msgstr ""

#~ msgid ""
#~ "The constructor of parent :class:`QgsFeatureRendererV2` class needs renderer"
#~ " name (has to be unique among renderers). :func:`symbolForFeature` method is"
#~ " the one that decides what symbol will be used for a particular feature. "
#~ ":func:`startRender` and :func:`stopRender` take care of "
#~ "initialization/finalization of symbol rendering. :func:`usedAttributes` "
#~ "method can return a list of field names that renderer expects to be present."
#~ " Finally :func:`clone` function should return a copy of the renderer."
#~ msgstr ""

#~ msgid ""
#~ "Like with symbol layers, it is possible to attach a GUI for configuration of"
#~ " the renderer. It has to be derived from :class:`QgsRendererV2Widget`. The "
#~ "following sample code creates a button that allows user to set symbol of the"
#~ " first symbol"
#~ msgstr ""

#~ msgid ""
#~ "The constructor receives instances of the active layer "
#~ "(:class:`QgsVectorLayer`), the global style (:class:`QgsStyleV2`) and "
#~ "current renderer. If there is no renderer or the renderer has different "
#~ "type, it will be replaced with our new renderer, otherwise we will use the "
#~ "current renderer (which has already the type we need). The widget contents "
#~ "should be updated to show current state of the renderer. When the renderer "
#~ "dialog is accepted, widget's :func:`renderer` method is called to get the "
#~ "current renderer --- it will be assigned to the layer."
#~ msgstr ""

#~ msgid ""
#~ "To associate an icon with the renderer you can assign it in "
#~ ":class:`QgsRendererV2AbstractMetadata` constructor as a third (optional) "
#~ "argument --- the base class constructor in the RandomRendererMetadata "
#~ ":func:`__init__` function becomes"
#~ msgstr ""

#~ msgid ""
#~ "The icon can be associated also at any later time using :func:`setIcon` "
#~ "method of the metadata class. The icon can be loaded from a file (as shown "
#~ "above) or can be loaded from a `Qt resource "
#~ "<http://qt.nokia.com/doc/4.5/resources.html>`_ (PyQt4 includes .qrc compiler"
#~ " for Python)."
#~ msgstr ""

#~ msgid "working with style (:class:`QgsStyleV2`)"
#~ msgstr ""

#~ msgid "working with color ramps (:class:`QgsVectorColorRampV2`)"
#~ msgstr ""

#~ msgid ""
#~ "rule-based renderer (see `this blogpost <http://snorf.net/blog/2014/03/04"
#~ "/symbology-of-vector-layers-in-qgis-python-plugins>`_)"
#~ msgstr ""

#~ msgid "Here is how you can use the the undo functionality:"
#~ msgstr ""

#~ msgid ""
#~ "add features to index --- index takes :class:`QgsFeature "
#~ "<qgis.core.QgsFeature>` object and adds it to the internal data structure. "
#~ "You can create the object manually or use one from a previous call to "
#~ "provider's :meth:`nextFeature() "
#~ "<qgis.core.QgsVectorDataProvider.nextFeature>`"
#~ msgstr ""

#~ msgid "From an instance of :class:`QgsVectorFileWriter`"
#~ msgstr ""

#~ msgid ""
#~ "The third parameter specifies output text encoding. Only some drivers need "
#~ "this for correct operation (Shapefile is one of those), but if you are not "
#~ "using international characters you do not have to care much about the "
#~ "encoding."
#~ msgstr ""

#~ msgid ""
#~ "The fourth parameter that we left as ``None`` may specify the destination "
#~ "CRS --- if a valid instance of :class:`QgsCoordinateReferenceSystem "
#~ "<qgis.core.QgsCoordinateReferenceSystem>` is passed, the layer is "
#~ "transformed to that CRS."
#~ msgstr ""

#~ msgid ""
#~ "For valid driver names please consult the `supported formats by OGR`_ --- "
#~ "you should pass the value in the \"Code\" column as the driver name. "
#~ "Optionally you can set whether to export only selected features, pass "
#~ "further driver-specific options for creation or tell the writer not to "
#~ "create attributes --- look into the documentation for full syntax."
#~ msgstr ""

#~ msgid "From an instance of :class:`QgsVectorLayer`"
#~ msgstr ""

#~ msgid ""
#~ "you can again use :func:`classAttribute` to find out classification "
#~ "attribute name, :func:`sourceSymbol` and :func:`sourceColorRamp` methods.  "
#~ "Additionally there is :func:`mode` method which determines how the ranges "
#~ "were created: using equal intervals, quantiles or some other method."
#~ msgstr ""

#~ msgid ""
#~ "Having an instance of a symbol (e.g. from a renderer), it is possible to "
#~ "explore it: :meth:`type <qgis.core.QgsSymbol.type>` method says whether it "
#~ "is a marker, line or fill symbol. There is a :meth:`dump "
#~ "<qgis.core.QgsSymbol.dump>` method which returns a brief description of the "
#~ "symbol. To get a list of symbol layers:"
#~ msgstr ""

#~ msgid ""
#~ "To find out symbol's color use :meth:`color <qgis.core.QgsSymbol.color>` "
#~ "method and :meth:`setColor <qgis.core.QgsSymbol.setColor>` to change its "
#~ "color. With marker symbols additionally you can query for the symbol size "
#~ "and rotation with :meth:`size <qgis.core.QgsSymbol.size>` and :meth:`angle "
#~ "<qgis.core.QgsSymbol.angle>` methods, for line symbols there is :meth:`width"
#~ " <qgis.core.QgsSymbol.width>` method returning line width."
#~ msgstr ""

#~ msgid ""
#~ ":class:`QgsSymbolLayerRegistry <qgis.core.QgsSymbolLayerRegistry>` class "
#~ "manages a database of all available"
#~ msgstr ""

#~ msgid "symbol layer types."
#~ msgstr ""

#~ msgid ""
#~ "To access symbol layer data, use its :meth:`properties() "
#~ "<qgis.core.QgsSymbolLayer.properties>` method that returns a key-value "
#~ "dictionary of properties which determine the appearance. Each symbol layer "
#~ "type has a specific set of properties that it uses. Additionally, there are "
#~ "generic methods :meth:`color <qgis.core.QgsSymbol.color>`, :meth:`size "
#~ "<qgis.core.QgsSymbol.size>`, :meth:`angle <qgis.core.QgsSymbol.angle>`, "
#~ ":meth:`width <qgis.core.QgsSymbol.width>` with their setter counterparts. Of"
#~ " course size and angle is available only for marker symbol layers and width "
#~ "for line symbol layers."
#~ msgstr ""

#~ msgid ""
#~ "The :meth:`layerType <qgis.core.QgsMarkerSymbolLayer.layerType>` method "
#~ "determines the name of the symbol layer, it has to be unique among all "
#~ "symbol layers. Properties are used for persistence of attributes. "
#~ ":meth:`clone <qgis.core.QgsMarkerSymbolLayer.clone>` method must return a "
#~ "copy of the symbol layer with all attributes being exactly the same. Finally"
#~ " there are rendering methods: :meth:`startRender "
#~ "<qgis.core.QgsMarkerSymbolLayer.startRender>` is called before rendering "
#~ "first feature, :meth:`stopRender "
#~ "<qgis.core.QgsMarkerSymbolLayer.stopRender>` when rendering is done. And "
#~ ":meth:`renderPoint <qgis.core.QgsMarkerSymbolLayer.renderPoint>` method "
#~ "which does the rendering. The coordinates of the point(s) are already "
#~ "transformed to the output coordinates."
#~ msgstr ""

#~ msgid ""
#~ "For polylines and polygons the only difference would be in the rendering "
#~ "method: you would use :meth:`renderPolyline "
#~ "<qgis.core.QgsMarkerSymbolLayer.renderPolyline>` which receives a list of "
#~ "lines, while :meth:`renderPolygon "
#~ "<qgis.core.QgsMarkerSymbolLayer.renderPolygon>` receives list of points on "
#~ "outer ring as a first parameter and a list of inner rings (or None) as a "
#~ "second parameter."
#~ msgstr ""

#~ msgid ""
#~ "This widget can be embedded into the symbol properties dialog. When the "
#~ "symbol layer type is selected in symbol properties dialog, it creates an "
#~ "instance of the symbol layer and an instance of the symbol layer widget. "
#~ "Then it calls :func:`setSymbolLayer` method to assign the symbol layer to "
#~ "the widget. In that method the widget should update the UI to reflect the "
#~ "attributes of the symbol layer. :func:`symbolLayer` function is used to "
#~ "retrieve the symbol layer again by the properties dialog to use it for the "
#~ "symbol."
#~ msgstr ""

#~ msgid ""
#~ "On every change of attributes, the widget should emit :func:`changed()` "
#~ "signal to let the properties dialog update the symbol preview."
#~ msgstr ""

#~ msgid ""
#~ "You should pass layer type (the same as returned by the layer) and symbol "
#~ "type (marker/line/fill) to the constructor of parent class. "
#~ ":meth:`createSymbolLayer() "
#~ "<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayer>` takes care of "
#~ "creating an instance of symbol layer with attributes specified in the "
#~ "`props` dictionary. And there is :meth:`createSymbolLayerWidget() "
#~ "<qgis.core.QgsSymbolLayerAbstractMetadata.createSymbolLayerWidget>` method "
#~ "which returns settings widget for this symbol layer type."
#~ msgstr ""

#~ msgid ""
#~ "The constructor of parent :class:`QgsFeatureRenderer` class needs a renderer"
#~ " name (which has to be unique among renderers). The :func:`symbolForFeature`"
#~ " method is the one that decides what symbol will be used for a particular "
#~ "feature. :func:`startRender` and :func:`stopRender` take care of "
#~ "initialization/finalization of symbol rendering. The :func:`usedAttributes` "
#~ "method can return a list of field names that renderer expects to be present."
#~ " Finally, the :func:`clone` function should return a copy of the renderer."
#~ msgstr ""

#~ msgid ""
#~ "Like with symbol layers, it is possible to attach a GUI for configuration of"
#~ " the renderer. It has to be derived from :class:`QgsRendererWidget`. The "
#~ "following sample code creates a button that allows user to set symbol of the"
#~ " first symbol"
#~ msgstr ""

#~ msgid ""
#~ "The constructor receives instances of the active layer "
#~ "(:class:`QgsVectorLayer`), the global style (:class:`QgsStyle`) and current "
#~ "renderer. If there is no renderer or the renderer has different type, it "
#~ "will be replaced with our new renderer, otherwise we will use the current "
#~ "renderer (which has already the type we need). The widget contents should be"
#~ " updated to show current state of the renderer. When the renderer dialog is "
#~ "accepted, widget's :func:`renderer` method is called to get the current "
#~ "renderer --- it will be assigned to the layer."
#~ msgstr ""

#~ msgid ""
#~ "Similarly as with symbol layers, abstract metadata constructor awaits "
#~ "renderer name, name visible for users and optionally name of renderer's "
#~ "icon. :func:`createRenderer` method passes :class:`QDomElement` instance "
#~ "that can be used to restore renderer's state from DOM tree. "
#~ ":func:`createRendererWidget` method creates the configuration widget. It "
#~ "does not have to be present or can return `None` if the renderer does not "
#~ "come with GUI."
#~ msgstr ""

#~ msgid ""
#~ "To associate an icon with the renderer you can assign it in "
#~ ":class:`QgsRendererAbstractMetadata` constructor as a third (optional) "
#~ "argument --- the base class constructor in the RandomRendererMetadata "
#~ ":func:`__init__` function becomes"
#~ msgstr ""

#~ msgid ""
#~ "The icon can be associated also at any later time using :func:`setIcon` "
#~ "method of the metadata class. The icon can be loaded from a file (as shown "
#~ "above) or can be loaded from a `Qt resource "
#~ "<https://doc.qt.io/qt-5/resources.html>`_ (PyQt5 includes .qrc compiler for "
#~ "Python)."
#~ msgstr ""

#~ msgid "|outofdate|"
#~ msgstr ""

#~ msgid ""
#~ "The constructor also takes a URI defining the geometry type of the layer, "
#~ "one of: ``\"Point\"``, ``\"LineString\"``, ``\"Polygon\"``, "
#~ "``\"MultiPoint\"``, ``\"MultiLineString\"``, or ``\"MultiPolygon\"``."
#~ msgstr ""
