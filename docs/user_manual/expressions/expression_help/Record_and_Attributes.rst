:orphan:

.. DO NOT EDIT THIS FILE DIRECTLY. It is generated automatically by
   populate_expressions_list.py in the scripts folder.
   Changes should be made in the function help files
   in the resources/function_help/json/ folder in the
   qgis/QGIS repository.

.. _expression_function_Record_and_Attributes_attribute:

attribute
.........

Returns an attribute from a feature.

**Variant 1**

Returns the value of an attribute from the current feature.

.. list-table::
   :widths: 15 85

   * - Syntax
     - attribute(attribute_name)
   * - Arguments
     - * **attribute_name** - name of attribute to be returned
   * - Examples
     - * ``attribute( 'name' )`` → value stored in 'name' attribute for the current feature


**Variant 2**

Allows the target feature and attribute name to be specified.

.. list-table::
   :widths: 15 85

   * - Syntax
     - attribute(feature, attribute_name)
   * - Arguments
     - * **feature** - a feature
       * **attribute_name** - name of attribute to be returned
   * - Examples
     - * ``attribute( @atlas_feature, 'name' )`` → value stored in 'name' attribute for the current atlas feature


.. end_attribute_section

.. _expression_function_Record_and_Attributes_attributes:

attributes
..........

Returns a map containing all attributes from a feature, with field names as map keys.

**Variant 1**

Returns a map of all attributes from the current feature.

.. list-table::
   :widths: 15 85

   * - Syntax
     - attributes()
   * - Examples
     - * ``attributes()['name']`` → value stored in 'name' attribute for the current feature


**Variant 2**

Allows the target feature to be specified.

.. list-table::
   :widths: 15 85

   * - Syntax
     - attributes(feature)
   * - Arguments
     - * **feature** - a feature
   * - Examples
     - * ``attributes( @atlas_feature )['name']`` → value stored in 'name' attribute for the current atlas feature


.. end_attributes_section

.. _expression_function_Record_and_Attributes_$currentfeature:

$currentfeature
...............

Returns the current feature being evaluated. This can be used with the 'attribute' function to evaluate attribute values from the current feature.

.. list-table::
   :widths: 15 85

   * - Syntax
     - $currentfeature
   * - Examples
     - * ``attribute( $currentfeature, 'name' )`` → value stored in 'name' attribute for the current feature


.. end_$currentfeature_section

.. _expression_function_Record_and_Attributes_display_expression:

display_expression
..................

Returns the display expression for a given feature in a layer. The expression is evaluated by default. Can be used with zero, one or more arguments, see below for details.

**No parameters**

If called with no parameters, the function will evaluate the display expression of the current feature in the current layer.

.. list-table::
   :widths: 15 85

   * - Syntax
     - display_expression()
   * - Examples
     - * ``display_expression()`` → The display expression of the current feature in the current layer.


**One 'feature' parameter**

If called with a 'feature' parameter only, the function will evaluate the specified feature from the current layer.

.. list-table::
   :widths: 15 85

   * - Syntax
     - display_expression(feature)
   * - Arguments
     - * **feature** - The feature which should be evaluated.
   * - Examples
     - * ``display_expression(@atlas_feature)`` → The display expression of the current atlas feature.


**Layer and feature parameters**

If the function is called with both a layer and a feature, it will evaluate the specified feature from the specified layer.

.. list-table::
   :widths: 15 85

   * - Syntax
     - display_expression(layer, feature, [evaluate=true])

       [] marks optional arguments
   * - Arguments
     - * **layer** - The layer (or its ID or name)
       * **feature** - The feature which should be evaluated.
       * **evaluate** - If the expression must be evaluated. If false, the expression will be returned as a string literal only (which could potentially be later evaluated using the 'eval' function).
   * - Examples
     - * ``display_expression( 'streets', get_feature_by_id('streets', 1))`` → The display expression of the feature with the ID 1 on the layer 'streets'.
       * ``display_expression('a_layer_id', $currentfeature, 'False')`` → The display expression of the given feature not evaluated.


.. end_display_expression_section

.. _expression_function_Record_and_Attributes_get_feature:

get_feature
...........

Returns the first feature of a layer matching a given attribute value.

**Single value variant**

Along with the layer ID, a single column and value are specified.

.. list-table::
   :widths: 15 85

   * - Syntax
     - get_feature(layer, attribute, value)
   * - Arguments
     - * **layer** - layer name or ID
       * **attribute** - attribute name to use for the match
       * **value** - attribute value to match
   * - Examples
     - * ``get_feature('streets','name','main st')`` → first feature found in "streets" layer with "main st" value in the "name" field


**Map variant**

Along with the layer ID, a map containing the columns (key) and their respective value to be used.

.. list-table::
   :widths: 15 85

   * - Syntax
     - get_feature(layer, attribute)
   * - Arguments
     - * **layer** - layer name or ID
       * **attribute** - Map containing the column and value pairs to use
   * - Examples
     - * ``get_feature('streets',map('name','main st','lane_num','4'))`` → first feature found in "streets" layer with "main st" value in the "name" field and  "4" value in the "lane_num" field


.. end_get_feature_section

.. _expression_function_Record_and_Attributes_get_feature_by_id:

get_feature_by_id
.................

Returns the feature with an id on a layer.

.. list-table::
   :widths: 15 85

   * - Syntax
     - get_feature_by_id(layer, feature_id)
   * - Arguments
     - * **layer** - layer, layer name or layer id
       * **feature_id** - the id of the feature which should be returned
   * - Examples
     - * ``get_feature_by_id('streets', 1)`` → the feature with the id 1 on the layer "streets"


.. end_get_feature_by_id_section

.. _expression_function_Record_and_Attributes_$id:

$id
...

Returns the feature id of the current row.

.. list-table::
   :widths: 15 85

   * - Syntax
     - $id
   * - Examples
     - * ``$id`` → 42


.. end_$id_section

.. _expression_function_Record_and_Attributes_is_selected:

is_selected
...........

Returns TRUE if a feature is selected. Can be used with zero, one or two arguments, see below for details.

**No parameters**

If called with no parameters, the function will return TRUE if the current feature in the current layer is selected.

.. list-table::
   :widths: 15 85

   * - Syntax
     - is_selected()
   * - Examples
     - * ``is_selected()`` → TRUE if the current feature in the current layer is selected.


**One 'feature' parameter**

If called with a 'feature' parameter only, the function returns TRUE if the specified feature from the current layer is selected.

.. list-table::
   :widths: 15 85

   * - Syntax
     - is_selected(feature)
   * - Arguments
     - * **feature** - The feature which should be checked for selection.
   * - Examples
     - * ``is_selected(@atlas_feature)`` → TRUE if the current atlas feature is selected.
       * ``is_selected(get_feature('streets', 'name', 'Main St.')))`` → TRUE if the unique named "Main St." feature on the active "streets" layer is selected.
       * ``is_selected(get_feature_by_id('streets', 1))`` → TRUE if the feature with the id 1 on the active "streets" layer is selected.


**Two parameters**

If the function is called with both a layer and a feature, it will return TRUE if the specified feature from the specified layer is selected.

.. list-table::
   :widths: 15 85

   * - Syntax
     - is_selected(layer, feature)
   * - Arguments
     - * **layer** - The layer (its ID or name) on which the selection will be checked.
       * **feature** - The feature which should be checked for selection.
   * - Examples
     - * ``is_selected( 'streets', get_feature('streets', 'name', "street_name"))`` → TRUE if the current building's street is selected (assuming the building layer has a field named 'street_name' and the 'streets' layer has a field called 'name' with unique values).
       * ``is_selected( 'streets', get_feature_by_id('streets', 1))`` → TRUE if the feature with the id 1 on the "streets" layer is selected.


.. end_is_selected_section

.. _expression_function_Record_and_Attributes_maptip:

maptip
......

Returns the maptip for a given feature in a layer. The expression is evaluated by default. Can be used with zero, one or more arguments, see below for details.

**No parameters**

If called with no parameters, the function will evaluate the maptip of the current feature in the current layer.

.. list-table::
   :widths: 15 85

   * - Syntax
     - maptip()
   * - Examples
     - * ``maptip()`` → The maptip of the current feature in the current layer.


**One 'feature' parameter**

If called with a 'feature' parameter only, the function will evaluate the specified feature from the current layer.

.. list-table::
   :widths: 15 85

   * - Syntax
     - maptip(feature)
   * - Arguments
     - * **feature** - The feature which should be evaluated.
   * - Examples
     - * ``maptip(@atlas_feature)`` → The maptip of the current atlas feature.


**Layer and feature parameters**

If the function is called with both a layer and a feature, it will evaluate the specified feature from the specified layer.

.. list-table::
   :widths: 15 85

   * - Syntax
     - maptip(layer, feature, [evaluate=true])

       [] marks optional arguments
   * - Arguments
     - * **layer** - The layer (or its ID or name)
       * **feature** - The feature which should be evaluated.
       * **evaluate** - If the expression must be evaluated. If false, the expression will be returned as a string literal only (which could potentially be later evaluated using the 'eval_template' function).
   * - Examples
     - * ``maptip('streets', get_feature_by_id('streets', 1))`` → The maptip of the feature with the ID 1 on the layer 'streets'.
       * ``maptip('a_layer_id', $currentfeature, 'False')`` → The maptip of the given feature not evaluated.


.. end_maptip_section

.. _expression_function_Record_and_Attributes_num_selected:

num_selected
............

Returns the number of selected features on a given layer. By default works on the layer on which the expression is evaluated.

.. list-table::
   :widths: 15 85

   * - Syntax
     - num_selected([layer=current layer])

       [] marks optional arguments
   * - Arguments
     - * **layer** - The layer (or its id or name) on which the selection will be checked.
   * - Examples
     - * ``num_selected()`` → The number of selected features on the current layer.
       * ``num_selected('streets')`` → The number of selected features on the layer streets


.. end_num_selected_section

.. _expression_function_Record_and_Attributes_represent_attributes:

represent_attributes
....................

Returns a map with the attribute names as keys and the configured representation values as values. The representation value for the attributes depends on the configured widget type for each attribute.  Can be used with zero, one or more arguments, see below for details.

**No parameters**

If called with no parameters, the function will return the representation of the attributes of the current feature in the current layer.

.. list-table::
   :widths: 15 85

   * - Syntax
     - represent_attributes()
   * - Examples
     - * ``represent_attributes()`` → The representation of the attributes for the current feature.


**One 'feature' parameter**

If called with a 'feature' parameter only, the function will return the representation of the attributes of the specified feature from the current layer.

.. list-table::
   :widths: 15 85

   * - Syntax
     - represent_attributes(feature)
   * - Arguments
     - * **feature** - The feature which should be evaluated.
   * - Examples
     - * ``represent_attributes(@atlas_feature)`` → The representation of the attributes for the specified feature from the current layer.


**Layer and feature parameters**

If called with a 'layer' and a 'feature' parameter, the function will return the representation of the attributes of the specified feature from the specified layer.

.. list-table::
   :widths: 15 85

   * - Syntax
     - represent_attributes(layer, feature)
   * - Arguments
     - * **layer** - The layer (or its ID or name).
       * **feature** - The feature which should be evaluated.
   * - Examples
     - * ``represent_attributes('atlas_layer', @atlas_feature)`` → The representation of the attributes for the specified feature from the specified layer.


.. end_represent_attributes_section

.. _expression_function_Record_and_Attributes_represent_value:

represent_value
...............

Returns the configured representation value for a field value. It depends on the configured widget type. Often, this is useful for 'Value Map' widgets.

.. list-table::
   :widths: 15 85

   * - Syntax
     - represent_value(value, fieldName)
   * - Arguments
     - * **value** - The value which should be resolved. Most likely a field.
       * **fieldName** - The field name for which the widget configuration should be loaded. (Optional)
   * - Examples
     - * ``represent_value("field_with_value_map")`` → Description for value
       * ``represent_value('static value', 'field_name')`` → Description for static value


.. end_represent_value_section

.. _expression_function_Record_and_Attributes_sqlite_fetch_and_increment:

sqlite_fetch_and_increment
..........................

Manage autoincrementing values in sqlite databases.

SQlite default values can only be applied on insert and not prefetched.


This makes it impossible to acquire an incremented primary key via AUTO_INCREMENT before creating the row in the database. Sidenote: with postgres, this works via the option *evaluate default values*.


When adding new features with relations, it is really nice to be able to already add children for a parent, while the parents form is still open and hence the parent feature uncommitted.


To get around this limitation, this function can be used to manage sequence values in a separate table on sqlite based formats like gpkg.


The sequence table will be filtered for a sequence id (filter_attribute and filter_value) and the current value of the id_field will be incremented by 1 and the incremented value returned.


If additional columns require values to be specified, the default_values map can be used for this purpose.


**Note**

This function modifies the target sqlite table. It is intended for usage with default value configurations for attributes.


When the database parameter is a layer and the layer is in transaction mode, the value will only be retrieved once during the lifetime of a transaction and cached and incremented. This makes it unsafe to work on the same database from several processes in parallel.


.. list-table::
   :widths: 15 85

   * - Syntax
     - sqlite_fetch_and_increment(database, table, id_field, filter_attribute, filter_value, [default_values])

       [] marks optional arguments
   * - Arguments
     - * **database** - Path to the sqlite file or geopackage layer
       * **table** - Name of the table that manages the sequences
       * **id_field** - Name of the field that contains the current value
       * **filter_attribute** - Name the field that contains a unique identifier for this sequence. Must have a UNIQUE index.
       * **filter_value** - Name of the sequence to use.
       * **default_values** - Map with default values for additional columns on the table. The values need to be fully quoted. Functions are allowed.
   * - Examples
     - * ``sqlite_fetch_and_increment(@layer, 'sequence_table', 'last_unique_id', 'sequence_id', 'global', map('last_change', 'date(''now'')', 'user', '''' || @user_account_name || ''''))`` → 0
       * ``sqlite_fetch_and_increment(layer_property(@layer, 'path'), 'sequence_table', 'last_unique_id', 'sequence_id', 'global', map('last_change', 'date(''now'')', 'user', '''' || @user_account_name || ''''))`` → 0


.. end_sqlite_fetch_and_increment_section

.. _expression_function_Record_and_Attributes_uuid:

uuid
....

Generates a Universally Unique Identifier (UUID) for each row using the Qt `QUuid::createUuid <https://doc.qt.io/qt-5/quuid.html#createUuid>`_ method.

.. list-table::
   :widths: 15 85

   * - Syntax
     - uuid([format='WithBraces'])

       [] marks optional arguments
   * - Arguments
     - * **format** - The format, as the UUID will be formatted. 'WithBraces', 'WithoutBraces' or 'Id128'.
   * - Examples
     - * ``uuid()`` → '{0bd2f60f-f157-4a6d-96af-d4ba4cb366a1}'
       * ``uuid('WithoutBraces')`` → '0bd2f60f-f157-4a6d-96af-d4ba4cb366a1'
       * ``uuid('Id128')`` → '0bd2f60ff1574a6d96afd4ba4cb366a1'


.. end_uuid_section

