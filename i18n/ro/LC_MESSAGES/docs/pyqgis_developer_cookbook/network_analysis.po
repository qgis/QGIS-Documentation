# 
# Translators:
# Sorin Călinică <scalinica@gmail.com>, 2014
msgid ""
msgstr ""
"Project-Id-Version: QGIS Documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-05 22:35\n"
"PO-Revision-Date: 2014-12-06 16:10+0000\n"
"Last-Translator: Sorin Călinică <scalinica@gmail.com>\n"
"Language-Team: Romanian (http://www.transifex.com/projects/p/qgis-documentation/language/ro/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ro\n"
"Plural-Forms: nplurals=3; plural=(n==1?0:(((n%100>19)||((n%100==0)&&(n!=0)))?2:1));\n"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:9
msgid "Network analysis library"
msgstr "Biblioteca de analiză a rețelelor"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:11
msgid ""
"Starting from revision `ee19294562 <https://github.com/qgis/Quantum-"
"GIS/commit/ee19294562b00c6ce957945f14c1727210cffdf7>`_ (QGIS >= 1.8) the new"
" network analysis library was added to the QGIS core analysis library. The "
"library:"
msgstr "Începând cu revizia `ee19294562 <https://github.com/qgis/Quantum-GIS/commit/ee19294562b00c6ce957945f14c1727210cffdf7>`_ (QGIS >= 1.8) noua bibliotecă de analiză de rețea a fost adaugată la biblioteca de analize de bază a QGIS. Biblioteca:"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:15
msgid ""
"creates mathematical graph from geographical data (polyline vector layers)"
msgstr "creează graful matematic din datele geografice (straturi vectoriale de tip polilinie)"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:24
msgid "General information"
msgstr "Informații generale"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:28
msgid "create graph from geodata (usually polyline vector layer)"
msgstr "crearea grafului din geodate (de obicei un strat vectorial de tip polilinie)"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:29
msgid "run graph analysis"
msgstr "rularea analizei grafului"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:30
msgid "use analysis results (for example, visualize them)"
msgstr "folosirea rezultatelor analizei (de exemplu, vizualizarea lor)"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:139
msgid "crs --- coordinate reference system to use. Mandatory argument."
msgstr "crs --- sistemul de coordonate de referință de utilizat. Argument obligatoriu."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:140
msgid ""
"otfEnabled --- use \"on the fly\" reprojection or no. By default "
"const:`True` (use OTF)."
msgstr "otfEnabled --- utilizați sau nu reproiectarea \"din zbor\". În mod implicit const:`True` (folosiți OTF)."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:142
msgid "topologyTolerance --- topological tolerance. Default value is 0."
msgstr "topologyTolerance --- toleranța topologică. Valoarea implicită este 0."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:143
msgid "ellipsoidID --- ellipsoid to use. By default \"WGS84\"."
msgstr "ellipsoidID --- elipsoidul de utilizat. În mod implicit \"WGS84\"."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:182
msgid "Graph analysis"
msgstr "Analiza grafului"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:209
msgid "source --- input graph"
msgstr "source --- graf de intrare"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:210
msgid ""
"startVertexIdx --- index of the point on the tree (the root of the tree)"
msgstr "startVertexIdx --- Indexul punctului de pe arbore (rădăcina arborelui)"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:211
msgid "criterionNum --- number of edge property to use (started from 0)."
msgstr "criterionNum --- numărul de proprietății marginii de folosit (începând de la 0)."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:217
msgid ""
"The :func:`dijkstra` method has the same arguments, but returns two arrays. "
"In the first array element i contains index of the incoming edge or -1 if "
"there are no incoming edges. In the second array element i contains distance"
" from the root of the tree to vertex i or DOUBLE_MAX if vertex i is "
"unreachable from the root."
msgstr "Metoda :func:`dijkstra` are aceleași argumente, dar întoarce două tablouri. În prima matrice, elementul i conține indexul marginii de intrare, sau -1 în cazul în care nu există margini de intrare. În a doua matrice, elementul i conține distanta de la rădăcina arborelui la nodul i, sau DOUBLE_MAX dacă rădăcina nodului este imposibil de căutat."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:267
msgid "Same thing but using :func:`dijkstra` method::"
msgstr "Același lucru, dar cu ajutorul metodei :func:`Dijkstra`::"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:16
msgid ""
"implements basic methods from graph theory (currently only Dijkstra's "
"algorithm)"
msgstr "implementează metode de bază din teoria grafurilor (în prezent, doar algoritmul lui Dijkstra)"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:19
msgid ""
"The network analysis library was created by exporting basic functions from "
"the RoadGraph core plugin and now you can use it's methods in plugins or "
"directly from the Python console."
msgstr "Biblioteca analizelor de rețea a fost creată prin exportarea funcțiilor de bază ale plugin-ului RoadGraph, iar acum aveți posibilitatea să-i utilizați metodele în plugin-uri sau direct în consola Python."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:26
msgid "Briefly, a typical use case can be described as:"
msgstr "Pe scurt, un caz tipic de utilizare poate fi descris astfel:"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:33
msgid "Building a graph"
msgstr "Construirea unui graf"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:35
msgid ""
"The first thing you need to do --- is to prepare input data, that is to "
"convert a vector layer into a graph. All further actions will use this "
"graph, not the layer."
msgstr "Primul lucru pe care trebuie să-l faceți --- este de a pregăti datele de intrare, ceea ce înseamnă conversia stratului vectorial într-un graf. Toate acțiunile viitoare vor folosi acest graf, și nu stratul."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:39
msgid ""
"As a source we can use any polyline vector layer. Nodes of the polylines "
"become graph vertexes, and segments of the polylines are graph edges. If "
"several nodes have the same coordinates then they are the same graph vertex."
" So two lines that have a common node become connected to each other."
msgstr "Ca și sursă putem folosi orice strat vectorial de tip polilinie. Nodurile poliliniilor devin noduri ale grafului, segmentele poliliniilor reprezentând marginile grafului. În cazul în care mai multe noduri au aceleași coordonate, atunci ele sunt în același nod al grafului. Astfel, două linii care au un nod comun devin conectate între ele."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:44
msgid ""
"Additionally, during graph creation it is possible to \"fix\" (\"tie\") to "
"the input vector layer any number of additional points. For each additional "
"point a match will be found --- the closest graph vertex or closest graph "
"edge. In the latter case the edge will be split and a new vertex added."
msgstr "În plus, în timpul creării grafului este posibilă \"fixarea\" ('legarea\") de stratul vectorial de intrare a oricărui număr de puncte suplimentare. Pentru fiecare punct suplimentar va fi găsită o potrivire --- cel mai apropiat nod sau cea mai apropiată muchie a grafului. În ultimul caz muchia va fi divizată iar noul nod va fi adăugat."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:49
msgid ""
"Vector layer attributes and length of an edge can be used as the properties "
"of an edge."
msgstr "Atributele stratului vectorial și lungimea unei muchii pot fi folosite ca proprietăți ale marginii."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:52
msgid ""
"Converting from a vector layer to the graph is done using the `Builder "
"<http://en.wikipedia.org/wiki/Builder_pattern>`_ programming pattern. A "
"graph is constructed using a so-called Director. There is only one Director "
"for now: `QgsLineVectorLayerDirector "
"<http://qgis.org/api/classQgsLineVectorLayerDirector.html>`_. The director "
"sets the basic settings that will be used to construct a graph from a line "
"vector layer, used by the builder to create the graph. Currently, as in the "
"case with the director, only one builder exists: `QgsGraphBuilder "
"<http://qgis.org/api/classQgsGraphBuilder.html>`_, that creates `QgsGraph "
"<http://qgis.org/api/classQgsGraph.html>`_ objects. You may want to "
"implement your own builders that will build a graphs compatible with such "
"libraries as `BGL "
"<http://www.boost.org/doc/libs/1_48_0/libs/graph/doc/index.html>`_ or "
"`NetworkX <http://networkx.lanl.gov/>`_."
msgstr "Convertorul din strat vectorial în graf este dezvoltat folosind modelul de programare al `Constructorului <http://en.wikipedia.org/wiki/Builder_pattern>`_. De construirea grafului răspunde așa-numitul Director. Există doar un singur Director pentru moment: `QgsLineVectorLayerDirector <http://qgis.org/api/classQgsLineVectorLayerDirector.html>`_. Directorul stabilește setările de bază ale Constructorului, care vor fi folosite pentru a construi un graf dintr-un strat vectorial de tip linie. În prezent, ca și în cazul Directorului, există doar un singur Constructor: `QgsGraphBuilder <http://qgis.org/api/classQgsGraphBuilder.html>`_, care creează obiecte <http://qgis.org/api/classQgsGraph.html>`_. Este posibil să doriți implementarea propriilor constructori care să construiască grafuri compatibile cu bibliotecile, cum ar fi `BGL <http://www.boost.org/doc/libs/1_48_0/libs/graph/doc/index.html>`_ sau `NetworkX <http://networkx.lanl.gov/>`_."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:63
msgid ""
"To calculate edge properties the programming pattern `strategy "
"<http://en.wikipedia.org/wiki/Strategy_pattern>`_ is used. For now only "
"`QgsDistanceArcProperter "
"<http://qgis.org/api/classQgsDistanceArcProperter.html>`_ strategy is "
"available, that takes into account the length of the route. You can "
"implement your own strategy that will use all necessary parameters. For "
"example, RoadGraph plugin uses a strategy that computes travel time using "
"edge length and speed value from attributes."
msgstr "Pentru a calcula proprietățile marginii este utilizată `strategia modelului de programare  <http://en.wikipedia.org/wiki/Strategy_pattern>`_. Pentru moment doar strategia `QgsDistanceArcProperter <http://qgis.org/api/classQgsDistanceArcProperter.html>`_ este disponibilă, care ia în considerare lungimea traseului. Puteți implementa propria strategie, care va folosi toți parametrii necesari. De exemplu, plugin-ul RoadGraph folosește strategia care calculează timpul de călătorie, folosind lungimea muchiei și valoarea vitezei din atribute."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:70
msgid "It's time to dive into the process."
msgstr "Este timpul de a aprofunda acest proces."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:72
msgid ""
"First of all, to use this library we should import the networkanalysis "
"module"
msgstr "Înainte de toate, pentru a utiliza această bibliotecă ar trebui să importăm modulul networkanalysis"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:78
msgid "Then some examples for creating a director"
msgstr "Apoi, câteva exemple pentru crearea unui director"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:93
msgid ""
"To construct a director  we should pass a vector layer, that will be used as"
" the source for the graph structure and information about allowed movement "
"on each road segment (one-way or bidirectional movement, direct or reverse "
"direction). The call looks like this"
msgstr "Pentru a construi un director ar trebui să transmitem stratul vectorial, care va fi folosit ca sursă pentru structura grafului și informațiile despre mișcările permise pe fiecare segment de drum (circulație unilaterală sau bilaterală, sens direct sau invers). Acest apel arată în felul următor"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:106
msgid "And here is full list of what these parameters mean:"
msgstr "Iată lista completă a ceea ce înseamnă acești parametri:"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:108
msgid "``vl`` --- vector layer used to build the graph"
msgstr "``vl`` --- stratul vectorial utilizat pentru a construi graf"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:109
msgid ""
"``directionFieldId`` --- index of the attribute table field, where "
"information about roads direction is stored. If ``-1``, then don't use this "
"info at all. An integer."
msgstr "``directionFieldId`` --- indexul câmpului din tabelul de atribute, în care sunt stocate informații despre direcțiile drumurilor. Dacă este ``-1``, atunci aceste informații nu se folosesc deloc. Număr întreg."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:112
msgid ""
"``directDirectionValue`` --- field value for roads with direct direction "
"(moving from first line point to last one). A string."
msgstr "``directDirectionValue`` --- valoarea câmpului pentru drumurile cu sens direct (trecere de la primul punct de linie la ultimul). Șir de caractere."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:114
msgid ""
"``reverseDirectionValue`` --- field value for roads with reverse direction "
"(moving from last line point to first one). A string."
msgstr "``reverseDirectionValue`` --- valoarea câmpului pentru drumurile cu sens invers (în mișcare de la ultimul punct al liniei până la primul). Șir de caractere."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:116
msgid ""
"``bothDirectionValue`` --- field value for bidirectional roads (for such "
"roads we can move from first point to last and from last to first). A "
"string."
msgstr "``bothDirectionValue`` --- valoarea câmpului pentru drumurile bilaterale (pentru astfel de drumuri putem trece de la primul la ultimul punct și de la ultimul la primul). Șir de caractere."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:118
msgid ""
"``defaultDirection`` --- default road direction. This value will be used for"
" those roads where field ``directionFieldId`` is not set or has some value "
"different from any of the three values specified above. An integer. ``1`` "
"indicates direct direction, ``2`` indicates reverse direction, and ``3`` "
"indicates both directions."
msgstr "``defaultDirection`` --- direcția implicită a drumului. Această valoare va fi folosită pentru acele drumuri în care câmpul ``directionFieldId`` nu este setat sau are o valoare diferită de oricare din cele trei valori specificate mai sus. Număr întreg. ``1`` indică sensul direct, ``2`` indică sensul inversă, iar ``3`` indică ambele sensuri."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:124
msgid ""
"It is necessary then to create a strategy for calculating edge properties"
msgstr "Este necesară, apoi, crearea unei strategii pentru calcularea proprietăților marginii"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:130
msgid "And tell the director about this strategy"
msgstr "Apoi spuneți directorului despre această strategie"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:136
msgid ""
"Now we can use the builder, which will create the graph. The QgsGraphBuilder"
" class constructor takes several arguments:"
msgstr "Acum putem crea constructorul, care va crea graful. Constructorul clasei QgsGraphBuilder ia mai multe argumente:"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:150
msgid ""
"Also we can define several points, which will be used in the analysis. For "
"example"
msgstr "De asemenea, putem defini mai multe puncte, care vor fi utilizate în analiză. De exemplu"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:158
msgid ""
"Now all is in place so we can build the graph and \"tie\" these points to it"
msgstr "Acum că totul este la locul lui, putem să construim graful și să \"legăm\" aceste puncte la el"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:164
msgid ""
"Building the graph can take some time (which depends on the number of "
"features in a layer and layer size). ``tiedPoints`` is a list with "
"coordinates of \"tied\" points. When the build operation is finished we can "
"get the graph and use it for the analysis"
msgstr "Construirea unui graf poate dura ceva timp (depinzând de numărul de entități dintr-un strat și de dimensiunea stratului). ``tiedPoints`` reprezintă o listă cu coordonatele punctelor \"asociate\". Când s-a terminat operațiunea de construire putem obține graful și să-l utilizăm pentru analiză"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:173
msgid "With the next code we can get the vertex indexes of our points"
msgstr "Cu următorul cod putem obține indecșii punctelor noastre"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:184
msgid ""
"Networks analysis is used to find answers to two questions: which vertexes "
"are connected and how to find a shortest path. To solve these problems the "
"network analysis library provides Dijkstra's algorithm."
msgstr "Analiza de rețea este utilizată pentru a găsi răspunsuri la două întrebări: care noduri sunt conectate și identificarea celei mai scurte căi. Pentru a rezolva această problemă, biblioteca de analiză de rețea oferă algoritmul lui Dijkstra."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:188
msgid ""
"Dijkstra's algorithm finds the shortest route from one of the vertexes of "
"the graph to all the others and the values of the optimization parameters. "
"The results can be represented as a shortest path tree."
msgstr "Algoritmul lui Dijkstra găsește cea mai bună cale între unul dintre vârfurile grafului și toate celelalte, precum și valorile parametrilor de optimizare. Rezultatele pot fi reprezentate ca cel mai scurt arbore."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:192
msgid ""
"The shortest path tree is a directed weighted graph (or more precisely --- "
"tree) with the following properties:"
msgstr "Arborele drumurilor cele mai scurte reprezintă un graf (sau mai precis --- arbore) orientat, ponderat, cu următoarele proprietăți:"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:195
msgid "only one vertex has no incoming edges — the root of the tree"
msgstr "doar un singur nod nu are muchii de intrare — rădăcina arborelui"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:196
msgid "all other vertexes have only one incoming edge"
msgstr "toate celelalte noduri au numai o margine de intrare"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:197
msgid ""
"if vertex B is reachable from vertex A, then the path from A to B is the "
"single available path and it is optimal (shortest) on this graph"
msgstr "dacă nodul B este accesibil din nodul A, apoi calea de la A la B este singura disponibilă și este optimă (cea mai scurtă) în acest graf"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:200
msgid ""
"To get the shortest path tree use the methods :func:`shortestTree` and "
":func:`dijkstra` of `QgsGraphAnalyzer "
"<http://qgis.org/api/classQgsGraphAnalyzer.html>`_ class. It is recommended "
"to use method :func:`dijkstra` because it works faster and uses memory more "
"efficiently."
msgstr "Pentru a obține cel mai scurt arbore folosiți metodele :func:`shortestTree` și :func:`dijkstra` ale clasei `QgsGraphAnalyzer <http://qgis.org/api/classQgsGraphAnalyzer.html>`_. Se recomandă utilizarea metodei :func:`dijkstra`, deoarece lucrează mai rapid și utilizează memoria mult mai eficient."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:205
msgid ""
"The :func:`shortestTree` method is useful when you want to walk around the "
"shortest path tree. It always creates a new graph object (QgsGraph) and "
"accepts three variables:"
msgstr "Metoda :func:`shortestTree` este utilă atunci când doriți să vă plimbați de-a lungul celei mai scurte căi. Aceasta creează mereu un nou obiect de tip graf (QgsGraph) care acceptă trei variabile:"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:227
msgid ""
"Here is some very simple code to display the shortest path tree using the "
"graph created with the :func:`shortestTree` method (select linestring layer "
"in TOC and replace coordinates with your own). **Warning**: use this code "
"only as an example, it creates a lots of `QgsRubberBand "
"<http://qgis.org/api/classQgsRubberBand.html>`_ objects and may be slow on "
"large data-sets."
msgstr "Iată un cod foarte simplu pentru a afișa arborele celei mai scurte căi, folosind graful creat cu metoda :func:`shortestTree` (selectați stratul linie în TOC și înlocuiți coordonatele cu ale dvs). **Atenție**: folosiți acest cod doar ca exemplu, deoarece el va crea o mulțime de obiecte `QgsRubberBand <http://qgis.org/api/classQgsRubberBand.html>`_ , putând fi lent pe seturi de date de mari dimensiuni."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:302
msgid "Finding shortest paths"
msgstr "Găsirea celor mai scurte căi"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:304
msgid ""
"To find the optimal path between two points the following approach is used. "
"Both points (start A and end B) are \"tied\" to the graph when it is built. "
"Then using the methods :func:`shortestTree` or :func:`dijkstra` we build the"
" shortest path tree with root in the start point A. In the same tree we also"
" find the end point B and start to walk through the tree from point B to "
"point A. The Whole algorithm can be written as"
msgstr "Pentru a găsi calea optimă între două puncte este utilizată următoarea abordare. Ambele puncte (se începe cu A și se termină cu B) sunt \"legate\" de un graf, atunci când se construiește. Apoi folosind metodele :func:`shortestTree` sau :func:`dijkstra` vom construi cel mai scurt arbore cu rădăcina în punctul de pornire A. În același arbore am găsit, de asemenea, punctul de final B și începem parcurgerea arborelui de la punctul B la punctul A. Întregul algoritm poate fi scris ca"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:321
msgid ""
"At this point we have the path, in the form of the inverted list of vertexes"
" (vertexes are listed in reversed order from end point to start point) that "
"will be visited during traveling by this path."
msgstr "În acest moment avem calea, sub formă de listă inversată de noduri (nodurile sunt listate în ordine inversă, de la punctul de final către cel de start), ele fiind vizitate în timpul parcurgerii căii."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:325
msgid ""
"Here is the sample code for QGIS Python Console (you will need to select "
"linestring layer in TOC and replace coordinates in the code with yours) that"
" uses method :func:`shortestTree`"
msgstr "Aici este codul de test pentru consola Python a QGIS (va trebui să selectați stratul linie în TOC și să înlocuiți coordonate din cod cu ale dvs.), care folosește metoda :func:`shortestTree`"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:379
msgid "And here is the same sample but using :func:`dikstra` method"
msgstr "Iar aici este același exemplu, dar folosind metoda :func:`dijkstra`"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:429
msgid "Areas of availability"
msgstr "Ariile de disponibilitate"

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:431
msgid ""
"The area of availability for vertex A is the subset of graph vertexes that "
"are accessible from vertex A and the cost of the paths from A to these "
"vertexes are not greater that some value."
msgstr "Aria de disponibilitate a nodului A este un subset de noduri ale graf-ului, care sunt accesibile din nodul A iar costurile căii de la A la aceste noduri nu sunt mai mari decât o anumită valoare."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:435
msgid ""
"More clearly this can be shown with the following example: \"There is a fire"
" station. Which parts of city can a fire truck reach in 5 minutes? 10 "
"minutes? 15 minutes?\". Answers to these questions are fire station's areas "
"of availability."
msgstr "Mai clar, acest lucru poate fi dovedit cu următorul exemplu: \"Există o echipă de intervenție în caz de incendiu. Ce zone ale orașului acoperă această echipă în 5 minute? Dar în 10 minute? Dar în 15 minute?\". Răspunsul la aceste întrebări îl reprezintă zonele de disponibilitate ale echipei de intervenție."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:440
msgid ""
"To find the areas of availability we can use method :func:`dijkstra` of the "
":class:`QgsGraphAnalyzer` class. It is enough to compare the elements of the"
" cost array with a predefined value. If cost[i] is less than or equal to a "
"predefined value, then vertex i is inside the area of availability, "
"otherwise it is outside."
msgstr "Pentru a găsi zonele de disponibilitate putem folosi metoda :func:`dijksta` a clasei :class:`QgsGraphAnalyzer`. Este suficientă compararea elementelor matricei de costuri cu valoarea predefinită. În cazul în care costul[i] este mai mic sau egal decât o valoare predefinită, atunci nodul i se află în zona de disponibilitate, în caz contrar este în afară."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:446
msgid ""
"A more difficult problem is to get the borders of the area of availability. "
"The bottom border is the set of vertexes that are still accessible, and the "
"top border is the set of vertexes that are not accessible. In fact this is "
"simple: it is the availability border based on the edges of the shortest "
"path tree for which the source vertex of the edge is accessible and the "
"target vertex of the edge is not."
msgstr "Mai dificilă este obținerea granițelor zonei de disponibilitate. Marginea de jos reprezintă un set de noduri care încă sunt accesibile, iar marginea de sus un set de noduri inaccesibile. De fapt, acest lucru este simplu: marginea disponibilă a atins aceste margini parcurgând arborele cel mai scurt, pentru care nodul de start este accesibil, spre deosebire de celelalt capăt, care nu este accesibil."

#: ../../source/docs/pyqgis_developer_cookbook/network_analysis.rst:453
msgid "Here is an example"
msgstr "Iată un exemplu"

#~ msgid ""
#~ "implements basics method of the graph theory (currently only Dijkstra's "
#~ "algorithm)"
#~ msgstr ""

#~ msgid ""
#~ "Network analysis library was created by exporting basics functions from "
#~ "RoadGraph core plugin and now you can use it's methods in plugins or "
#~ "directly from Python console."
#~ msgstr ""

#~ msgid "Briefly typical use case can be described as:"
#~ msgstr ""

#~ msgid "Building graph"
#~ msgstr ""

#~ msgid ""
#~ "The first thing you need to do --- is to prepare input data, that is to "
#~ "convert vector layer into graph. All further actions will use this graph, "
#~ "not the layer."
#~ msgstr ""

#~ msgid ""
#~ "As a source we can use any polyline vector layer. Nodes of the polylines "
#~ "become graph vertices, and segments of the polylines are graph edges. If "
#~ "several nodes have the same coordinates then they are the same graph vertex."
#~ " So two lines that have a common node become connected to each other."
#~ msgstr ""

#~ msgid ""
#~ "Additionally, during graph creation it is possible to \"fix\" (\"tie\") to "
#~ "the input vector layer any number of additional points. For each additional "
#~ "point a match will be found --- closest graph vertex or closest graph edge. "
#~ "In the latter case the edge will be splitted and new vertex added."
#~ msgstr ""

#~ msgid ""
#~ "As the properties of the edge a vector layer attributes can be used and "
#~ "length of the edge."
#~ msgstr ""

#~ msgid ""
#~ "Converter from vector layer to graph is developed using `Builder "
#~ "<http://en.wikipedia.org/wiki/Builder_pattern>`_ programming pattern. For "
#~ "graph construction response so-called Director. There is only one Director "
#~ "for now: `QgsLineVectorLayerDirector "
#~ "<http://qgis.org/api/api/classQgsLineVectorLayerDirector.html>`_. The "
#~ "director sets the basic settings that will be used to construct a graph from"
#~ " a line vector layer, used by the builder to create graph. Currently, as in "
#~ "the case with the director, only one builder exists: `QgsGraphBuilder "
#~ "<http://qgis.org/api/api/classQgsGraphBuilder.html>`_, that creates "
#~ "`QgsGraph <http://qgis.org/api/api/classQgsGraph.html>`_ objects. You may "
#~ "want to implement your own builders that will build a graphs compatible with"
#~ " such libraries as `BGL "
#~ "<http://www.boost.org/doc/libs/1_48_0/libs/graph/doc/index.html>`_ or "
#~ "`NetworkX <http://networkx.lanl.gov/>`_."
#~ msgstr ""

#~ msgid ""
#~ "To calculate edge properties programming pattern `strategy "
#~ "<http://en.wikipedia.org/wiki/Strategy_pattern>`_ is used. For now only "
#~ "`QgsDistanceArcProperter "
#~ "<http://qgis.org/api/api/classQgsDistanceArcProperter.html>`_ strategy is "
#~ "available, that takes into account the length of the route. You can "
#~ "implement your own strategy that will use all necessary parameters. For "
#~ "example, RoadGraph plugin uses strategy that compute travel time using edge "
#~ "length and speed value from attributes."
#~ msgstr ""

#~ msgid "It's time to dive in the process."
#~ msgstr ""

#~ msgid ""
#~ "First of all, to use this library we should import networkanalysis module::"
#~ msgstr ""

#~ msgid "Than create director::"
#~ msgstr ""

#~ msgid ""
#~ "To construct a director  we should pass vector layer, that will be used as "
#~ "source for graph and information about allowed movement on each road segment"
#~ " (unilateral or bilateral movement, direct or reverse direction). Here is "
#~ "full list of this parameters:"
#~ msgstr ""

#~ msgid "vl --- vector layer used to build graph"
#~ msgstr ""

#~ msgid ""
#~ "directionFieldId --- index of the attribute table field, where information "
#~ "about roads directions is stored. If -1, then don't use this info at all"
#~ msgstr ""

#~ msgid ""
#~ "directDirectionValue --- field value for roads with direct direction (moving"
#~ " from first line point to last one)"
#~ msgstr ""

#~ msgid ""
#~ "reverseDirectionValue --- field value for roads with reverse direction "
#~ "(moving from last line point to first one)"
#~ msgstr ""

#~ msgid ""
#~ "bothDirectionValue --- field value for bilateral roads (for such roads we "
#~ "can move from first point to last and from last to first)"
#~ msgstr ""

#~ msgid ""
#~ "defaultDirection --- default road direction. This value will be used for "
#~ "those roads where field directionFieldId is not set or have some value "
#~ "different from above."
#~ msgstr ""

#~ msgid ""
#~ "It is necessary then to create strategy for calculating edge properties::"
#~ msgstr ""

#~ msgid "And tell the director about this strategy::"
#~ msgstr ""

#~ msgid ""
#~ "Now we can create builder, which will create graph. QgsGraphBuilder "
#~ "constructor takes several arguments:"
#~ msgstr ""

#~ msgid ""
#~ "Also  we can set several points, which will be used in analysis. For "
#~ "example::"
#~ msgstr ""

#~ msgid "Now all is in place so we can build graph and \"tie\" points to it::"
#~ msgstr ""

#~ msgid ""
#~ "Building graph can take some time (depends on number of features in a layer "
#~ "and layer size). tiedPoints is a list with coordinates of \"tied\" points. "
#~ "When build operation is finished we can get graph and use it for the "
#~ "analysis::"
#~ msgstr ""

#~ msgid "With the next code we can get indexes of our points::"
#~ msgstr ""

#~ msgid ""
#~ "Networks analysis is used to find answers on two questions: which vertices "
#~ "are connected and how to find a shortest path. To solve this problems "
#~ "network analysis library provides Dijkstra's algorithm."
#~ msgstr ""

#~ msgid ""
#~ "Dijkstra's algorithm finds the best route from one of the vertices of the "
#~ "graph to all the others and the values of the optimization parameters. The "
#~ "results can be represented as shortest path tree."
#~ msgstr ""

#~ msgid ""
#~ "The shortest path tree is as oriented weighted graph (or more precisely --- "
#~ "tree) with the following properties:"
#~ msgstr ""

#~ msgid "only one vertex have no incoming edges — the root of the tree"
#~ msgstr ""

#~ msgid "all other vertices have only one incoming edge"
#~ msgstr ""

#~ msgid ""
#~ "if vertex B is reachable from vertex A, then path from A to B is single "
#~ "available path and it is optimal (shortest) on this graph"
#~ msgstr ""

#~ msgid ""
#~ "To get shortest path tree use methods Use methods :func:`shortestTree` and "
#~ ":func:`dijkstra` of `QgsGraphAnalyzer "
#~ "<http://qgis.org/api/api/classQgsGraphAnalyzer.html>`_ class. It is "
#~ "recommended to use method :func:`dijkstra` because it works faster and uses "
#~ "memory more efficiently."
#~ msgstr ""

#~ msgid ""
#~ "The :func:`shortestTree` method is useful when you want to walk around the "
#~ "shortest path tree. It always creates new graph object (QgsGraph) and "
#~ "accepts three variables:"
#~ msgstr ""

#~ msgid ""
#~ "Here is very simple code to display shortest path tree using graph created "
#~ "with :func:`shortestTree` method (select linestring layer in TOC and replace"
#~ " coordinates with yours one). **Warning**: use this code only as an example,"
#~ " it creates a lots of `QgsRubberBand "
#~ "<http://qgis.org/api/api/classQgsRubberBand.html>`_ objects and may be slow "
#~ "on large datasets."
#~ msgstr ""

#~ msgid "Finding shortest path"
#~ msgstr ""

#~ msgid ""
#~ "To find optimal path between two points the following approach is used. Both"
#~ " points (start A and end B) are \"tied\" to graph when it builds. Than using"
#~ " methods :func:`shortestTree` or :func:`dijkstra` we build shortest tree "
#~ "with root in the start point A. In the same tree we also found end point B "
#~ "and start to walk through tree from point B to point A. Whole algorithm can "
#~ "be written as::"
#~ msgstr ""

#~ msgid ""
#~ "At this point we have path, in the form of the inverted list of vertices "
#~ "(vertices are listed in reversed order from end point to start one) that "
#~ "will be visited during traveling by this path."
#~ msgstr ""

#~ msgid ""
#~ "Here is the sample code for QGIS Python Console (you will need to select "
#~ "linestring layer in TOC and replace coordinates in the code with yours) that"
#~ " uses method :func:`shortestTree`::"
#~ msgstr ""

#~ msgid "And here is the same sample but using :func:`dikstra` method::"
#~ msgstr ""

#~ msgid "Areas of the availability"
#~ msgstr ""

#~ msgid ""
#~ "Area of availability for vertex A is a subset of graph vertices, that are "
#~ "accessible from vertex A and cost of the path from A to this vertices are "
#~ "not greater that some value."
#~ msgstr ""

#~ msgid ""
#~ "More clearly this can be shown with the following example: \"There is a fire"
#~ " station. What part of city fire command can reach in 5 minutes? 10 minutes?"
#~ " 15 minutes?\". Answers on this questions are fire station's areas of "
#~ "availability."
#~ msgstr ""

#~ msgid ""
#~ "To find areas of availablity we can use method :func:`dijksta` of the "
#~ ":class:`QgsGraphAnalyzer` class. It is enough to compare elements of cost "
#~ "array with predefined value. If cost[ i ] is less or equal than predefined "
#~ "value, than vertex i is inside area of availability, otherwise --- outside."
#~ msgstr ""

#~ msgid ""
#~ "More difficult it is to get borders of area of availablity. Bottom border "
#~ "--- is a set of vertices that are still accessible, and top border --- is a "
#~ "set of vertices which are not accesible. In fact this is simple: "
#~ "availability border passed on such edges of the shortest path tree for which"
#~ " start vertex is accessible and end vertex is not accessible."
#~ msgstr ""

#~ msgid "Here is an example::"
#~ msgstr ""
